<!DOCTYPE html>
<html lang="ko">

  <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG"></script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Opaque As Alpha Test</title>
  <meta name="description" content="Shader 에서 샘플링하는 Texutre 에서 Alpha 값을 가지고 있어, Alpha 을 참조해서 실제 픽셀에 출력을 하는지 안하는지를 결정하는 것을 Alpha Test 라고 한다. 이런 Material 이나 Texture 를 Cutout 이라고 통칭하는 경우가 많다. 보통 게임에서의 Alpha Test 를 사용하는 것들은 나무, 풀 같은 식생들(Vegetation)이 있고, 중간에 구멍이 뚫린 펜스같은 것들도 존재한다. 자연을 배경으로하는 게임의 경우에는 식생들이 굉장히 많기 때문에 Alpha Test 를 사용하는 Shader 가 굉장히 많이 사용될 것이다.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://suhyeokkim.github.io/2018/05/22/opaque-as-alpha-test">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://suhyeokkim.github.io/feed.xml">

  <meta name="google-site-verification" content="o3-a11YI0ZIYwUdcikrWBRObGOUHzk89IJF7CX0ieQk" />

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Opaque As Alpha Test">
  <meta name="twitter:description" content="Shader 에서 샘플링하는 Texutre 에서 Alpha 값을 가지고 있어, Alpha 을 참조해서 실제 픽셀에 출력을 하는지 안하는지를 결정하는 것을 Alpha Test 라고 한다. 이런 Material 이나 Texture 를 Cutout 이라고 통칭하는 경우가 많다. 보통 게임에서의 Alpha Test 를 사용하는 것들은 나무, 풀 같은 식생들(...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Opaque As Alpha Test</h1>
    
    <p class="post-meta"><time datetime="2018-05-22T00:00:00+00:00" itemprop="datePublished">May 22, 2018</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Su-Hyeok Kim</span></span> • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/alphatest/">alphatest</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>Shader</em> 에서 샘플링하는 <em>Texutre</em> 에서 <em>Alpha</em> 값을 가지고 있어, <em>Alpha</em> 을 참조해서 실제 픽셀에 출력을 하는지 안하는지를 결정하는 것을 <em>Alpha Test</em> 라고 한다. 이런 <em>Material</em> 이나 <em>Texture</em> 를  <em>Cutout</em> 이라고 통칭하는 경우가 많다.</p>

<p>보통 게임에서의 <em>Alpha Test</em> 를 사용하는 것들은 나무, 풀 같은 식생들(<em>Vegetation</em>)이 있고, 중간에 구멍이 뚫린 펜스같은 것들도 존재한다. 자연을 배경으로하는 게임의 경우에는 식생들이 굉장히 많기 때문에 <em>Alpha Test</em> 를 사용하는 <em>Shader</em> 가 굉장히 많이 사용될 것이다.</p>

<!-- more -->

<p><br />
<img src="/images/1_8EKqWSOOPXaTrDHVFTACJg.png" alt="Wikipedia : Single-precision floating-point format" class="center-image" /></p>
<center>출처 : <a href="https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">Anti-aliased Alpha Test: The Esoteric Alpha To Coverage</a>
</center>
<p><br /></p>

<p>하지만 <em>Alpha Test</em> 는 굉장히 큰 단점이 있다. 고정된 화면 해상도에서 물체가 작게 표현되면 물체를 표현할 수 있는 픽셀의 숫자가 많이 작아진다. 물체를 표현하는 픽셀의 수가 작아지게 되면 일반적으로 해당 넓이에 맞게 생성된 <em>Texture</em> 의 <em>Mip-level</em> 에 접근한다. 중간의 <em>Alpha Test</em> 그림을 보면된다.</p>

<p><br />
<img src="/images/1_zNbZFiJXjcqqyTkM9eEt7w.gif" alt="Wikipedia : Single-precision floating-point format" class="center-image" /></p>
<center>출처 : <a href="https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">Anti-aliased Alpha Test: The Esoteric Alpha To Coverage</a>
</center>
<p><br /></p>

<p>실제로는 양 옆의 물체들처럼 자연스럽게 표현이 되야하지만 일반적인 <em>Alpha Test</em> 를 사용하게 되면 위와 같은 현상에 마주치게 된다. 이는 굉장히 끔찍한 현상이다. 실제 게임을 해보거나, 만들어본 사람이라면 안다. 대부분의 픽셀에 나무가 표현되고, 잎사귀들이 저런식으로 자글자글 거린다면 약간의 불쾌함이 느껴진다. VR 이라면 더욱..</p>

<p>그래서 급하게 대처방안으로 나온 것이 위 그림의 오른쪽에 나오는 <em>Alpha to Coverage</em> 라는 방법이다. 이는 하드웨어 <em>MSAA</em> 를 픽셀 쉐이더의 결과를 통해 자동으로 해주는것으로, <em>MSAA</em> 의 퍼포먼스와 비례한다. <em>MSAA</em> 는 성능이 영 좋지않아 안쓰는 경우가 꽤 많이 존재하기 때문에 <em>Alpha to Coverage</em> 는 절대적으로 사용할 수 있는 방법은 아니다. 게다가 엄청나게 많은 나무를 <em>Alpha to Coverage</em> 를 쓴다면.. 성능은 안봐도 뻔하다.</p>

<p>앞서 말한 <em>Alpha Test</em> 은 <em>Material</em>, <em>Shader</em> 별로 고정된 <em>Alpha</em> 값을 설정해 그 이하가 되면 <em>Pixel Shader</em> 에서 결과를 내놓지 않게 하는(<em>Discard</em>) 방법이였다. <em>Alpha Test</em> 의 문제는 샘플링한 <em>Alpha</em> 값이 가끔 극단적으로 낮아서 <em>Discard</em> 되는 것인데, 이를 간단하게 해결하기 위해 요상한 방법이 등장했다.</p>

<p>바로 <em>Stochastic test</em> 라는 방법이다.</p>

<p><br />
<img src="/images/stochastic_sampling.png" alt="NVidia deverloper : Hashed Alpha Testing" class="center-image" /></p>
<center>출처 : <a href="https://developer.download.nvidia.com/assets/gameworks/downloads/regular/GDC17/RealTimeRenderingAdvances_HashedAlphaTesting_GDC2017_FINAL.pdf?pUIX8DXxfad7mL4zB3GOthX3r5IgGao9UWxYuYb3q9h10RXrQeYko-dEuJXJxt1hhsI9J_9KJDcCYGeWWksxlaHTrXSE825D_3izja7LUFOtzhaeBUqpn7qbwXaaGlLdbipjE3PeI3e2IMn45mQAA3OV2PD-kG2y9cecTaWE2uum2uwdHgyn0nhYiLOvlOsrUzewbK5REH7vAm3-lNWzxehw_5Tphg">NVidia developer : Hashed Alpha Testing</a>
</center>
<p><br /></p>

<p>위 그림에서 위쪽에 있는 것이 일반적인 <em>Alpha Test</em> 인데, <em>color.a</em> 는 텍스쳐에서 샘플링한 <em>Alpha</em> 값, <em>ατ</em> 는 <em>Alpha Test</em> 를 위한 고정된 <em>Alpha Threshold</em>(<em>알파한계</em>)다. 밑의 코드에서 <em>drand48</em> 이 나타내는 것은 단순한 0 ~ 1 사이의 랜덤값이다. 즉 랜덤하게 <em>Alpha Threshold</em> 를 설정해주어 물체가 멀어져서 평균 <em>Alpha</em> 값이 낮아질 때도 픽셀이 <em>Discard</em> 되지 않도록 하는 것이다. 하지만 이는 굉장한 눈아픔? 반짝거림? 을 유발한다. 범위를 지정해주지 않았기 때문에 이전 프레임에서 출력된 픽셀이 다음 프레임에서는 출력되지 않을 수도 있다. 이렇게 각 프레임마다 상황이 달라서 생기는 현상앞에 <em>Temporal</em> 을 붙인다. <em>Stochastic Alpha Test</em> 의 문제는 <em>Temporal Flickering</em> 이라고 할 수 있겠다.</p>

<p><em>Temporal Flickering</em> 이 없는, <em>Temporal Stability</em>(임시적 안정성) 을 확보하기 위해서는 <em>Alpha Threshold</em> 를 이러저리 튀지 않게해야 했고, 이를 위해 특정 값에 따라서 <em>Hash</em> 값을 생성하는 방법이 고안되었다. 이 방법은 <em>Hashed Alpha Test</em> 라는 이름으로 작년에 공개되었다.</p>
      <h2>
        
        
          Hashed Alpha Testing
        
        
      </h2>
    

<p>기본적으로 랜덤 값(난수) 생성은 제대로된 난수생성이 아닌, 특수한 식을 사용해서 의사 난수 생성 방법을 이용하는데, <em>Hash</em> 를 이용한 난수생성은 일반적으로 많이 쓰인다고 한다. <em>Hashed Alpha Testing</em> 은 <em>Hash</em> 를 생성하기 위한 <em>Key</em> 값을 선정하는데 조심스러웠다고 한다.</p>

<p><em>Key</em> 로 선정될 수 있는 후보는 <em>Texture Coordinate</em>, <em>World-Space Coordinate</em>, <em>Ojbect-Space Coordinate</em> 이 세가지 였다고 한다. <em>Texture Coordinate</em> 는 가끔 없는 경우가 있어 제외하였고, <em>World-Space Coordinate</em> 는 정적 물체에는 원하는대로 동작하지만, 동적 물체의 경우에는 문제가 있었다고 한다. 결국 남은건 <em>Ojbect-Space Coordinate</em> 가 남게 되었다.</p>

<p><em>Ojbect-Space Coordinate</em> 의 <em>X,Y,Z</em> 세 좌표를 모두 이용하게 되는데, 이는 <em>X,Y</em> 두개만 이용하게 되면 <em>Hash</em> 값이 <em>Screen-Space</em> 에서 생성되어 다른 물체와 겹치게 되면 <em>Alpha to Coverge</em> 같은 효과를 내게되어 3가지 좌표 모두 <em>Hash</em> 생성에 사용된다고 한다.</p>

<p>마지막으로 중요한 포인트는 <em>Temporal Stability</em> 를 확보하는 것이다. 이해하기 쉽게 설명하자면, 아래와 같은 각 픽셀을 나타내는 그리드안에 점이 있다고 가정해보자. 이 점들이 조금씩 움직여서 계속 픽셀안에 있다면, 같은 <em>Hash</em> 값을 사용하여 같은 <em>Alpha Threshold</em> 값을 만들어줘야 한다.</p>

<p><img src="/images/subpixel_0.png" alt="Subpixel 0" class="center-image" /></p>

<p>아래 두 그림의 빨간 점의 위치처럼 원래의 픽셀위치를 벗어나게 된다면 새로운 <em>Alpha Threshold</em> 를 생성해야 하겠지만, 위치가 많이 바뀌지 않는다면 같은 <em>Alpha Threshold</em> 를 사용해 <em>Flickering</em> 을 최대한 줄여야 한다.</p>

<p><img src="/images/subpixel_2.png" alt="Subpixel 2" class="center-image" /></p>

<p>이러한 맥락으로 <em>Hashed ALpha Testing</em> 은 <em>Temporal Stability</em> 를 조금 확보하게 된다. 물론 위의 그림은 이해를 돕기위한 용도로, 실제 코드상에서는 다른 방법을 통해 계산된다. 아래 코드를 보자.</p>

<p><br />
<img src="/images/hat_codesnippet_screenxy.png" alt="Hashed Alpha Testing" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg17_hashedAlphaExtended.pdf">Cwyman.org : Hashed Alpha Test(Extended)</a>
</center>
<p><br /></p>

<p>위 코드는 픽셀이 가지고 있는 <em>Object-Space Coordinate</em> 의 옆 픽셀과의 차이, 세로에 있는 픽셀과의 차이를 통한 값으로 계산한다. (dFdX, dFdY 의 자세한 내용은 찾아보거나 <a href="/2018/03/04/what-is-ddx-and-ddy">What is ddx and ddy</a> 에서 볼 수 있다.) 픽셀별로 값의 차이, 즉 근접한 픽셀의 위치 차이값에 따른값(미분값)과 그 값을 이용해 <em>Object-Space Coordinate</em> 값에 곱한 값을 <em>Key</em> 로 두어서 <em>Alpha Threshold</em> 를 계산한다.</p>

<p>마지막에 <em>Alpha Threshold</em> 를 구하는 코드를 보면, <em>Floor</em> 하는, 올림을 해주어 <em>discrete value</em> 로 <em>Key</em> 값을 넣어준다. <em>Floor</em> 가 의미하는 것은, 선형적인 데이터가 아닌 뚝뚝 끊기는 데이터로 만들어 특정한 값을 넘어야 <em>Key</em> 값이 바뀌게 하여 <em>Hash</em> 를 유지해 <em>Flickering</em> 을 방지하는 것이다. 아래 그림은 <em>floor(x)</em> 의 그래프다. 즉 코드의 <em>pixScale</em> 이 크면 클수록 <em>Hash</em> 의 값은 픽셀의 변화에 따라서 빠르게 바뀌고, 작으면 작을수록(0에 가까워질수록) 픽셀의 변화에 따라서 <em>Hash</em> 값이 느리게 바뀔 것이다.</p>

<p><br />
<img src="/images/wolframalpha_floor.gif" alt="Woflram Alpha : Floor Graph" class="center-image" /></p>
<center>출처 : <a href="http://www.wolframalpha.com/input/?i=floor">Wolframalpha</a>
</center>
<p><br /></p>

<p>이러한 방법은 <em>View-Space</em> 를 기준으로 <em>X,Y</em> 좌표가 조금씩 바뀔때는 픽셀끼리의 차이를 계산하기 때문에 안정적이다. 하지만 <em>Z(Depth)</em> 값이 바뀔때는 많은 <em>Flickering</em> 을 일으킬 것이다. 이를 해결하기 위해 아래 코드를 보자.</p>

<p><br />
<img src="/images/hat_codesnippet_screenz0.png" alt="Hashed Alpha Testing" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg17_hashedAlphaExtended.pdf">Cwyman.org : Hashed Alpha Test(Extended)</a>
</center>
<p><br /></p>

<p>위치의 픽셀별 차이 벡터의 크기를 <em>discrete</em> 시키는 방법도 좋은 아이디어중 하나다. 하지만 이는 빌보드처럼 큰 크기의 판이 다가오게 된다면 끝부분의 <em>discontinuity</em> 를 유발하게 된다.</p>

<p><br />
<img src="/images/hat_codesnippet_screenz1.png" alt="Hashed Alpha Testing" class="center-image" />
<img src="/images/hat_codesnippet_lerpscale.png" alt="Hashed Alpha Testing" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg17_hashedAlphaExtended.pdf">Cwyman.org : Hashed Alpha Test(Extended)</a>
</center>
<p><br /></p>

<p>그래서 위 코드와 같 <em>discretize</em> 시킨 올림처리한 값과, 내림처리한 값을 사용한 두 <em>Hash</em> 값 사이의 보간을 통해서 <em>Alpha Threshold</em> 를 구해준다. 하지만 이 코드는 아직 문제점이 존재한다. 만약 <em>maxDeriv</em> 의 값이 0 ~ 1 사이라면 내림값이 반드시 0이 되기 때문에 보간할 값 중 한개의 값이 고정되게 된다. 그래서 아래와 같은 코드를 사용한다.</p>

<p><br />
<img src="/images/hat_codesnippet_exp2.png" alt="Hashed Alpha Testing" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg17_hashedAlphaExtended.pdf">Cwyman.org : Hashed Alpha Test(Extended)</a>
</center>
<p><br /></p>

<p><em>pixScale</em> 을 그냥 계산하는 대신, <em>discretize</em> 된 두개의 스케일값을 2의 지수로 표현하여 값이 0으로 되는 것을 막는다. 이렇게 보간된 값을 사용하여 <em>Alpha Threshold</em> 를 정해주면 약간의 문제가 생긴다. 보간을 함으로써 균일하지 않게 랜덤값이 분포되었기 때문이다. 그래서 아래와 같은 식을 사용하여 다시 값을 분포시켜준다.</p>

<p><br />
<img src="/images/hat_codesnippet_cdf.png" alt="Hashed Alpha Testing" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg17_hashedAlphaExtended.pdf">Cwyman.org : Hashed Alpha Test(Extended)</a>
</center>
<p><br /></p>

<p>위의 식을 적용하면 모든 값들이 균일하게 분포되어 진정한 랜덤값의 <em>Alpha Threshold</em> 가 생성된다고 한다. 아래는 전체 코드다.</p>

<p><br />
<img src="/images/hat_codesnippet_whole.png" alt="Hashed Alpha Testing" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg17_hashedAlphaExtended.pdf">Cwyman.org : Hashed Alpha Test(Extended)</a>
</center>
<p><br /></p>

<p>자세한 사항은 논문에서 확인할 수 있다(<a href="http://cwyman.org/papers/tvcg17_hashedAlphaExtended.pdf">[Cwyman17]</a>). 결과는 아래 유튜브 영상에서 확인할 수 있다.</p>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">    <iframe title="YouTube video player" width="640" height="390" src="//www.youtube.com/embed/p4TYf5DDpbQ" frameborder="0" allowfullscreen=""></iframe></div>

<p>이를 통해 전보다 훨씬 나은 <em>Alpha Test</em> 품질을 얻을 수 있게 되었다. 하지만 <em>Hashed Alpha Testing</em> 의 결과는 <em>Stochastic Test</em> 처럼 픽셀이 흩뿌려진 느낌을 지울 수 없다. 어느정도의 랜덤값에서 생성이되니 이는 어쩔 수 없는 결과다.</p>
      <h2>
        
        
          Alpha Distribution
        
        
      </h2>
    

<p><em>Alpha Test</em> 의 구린 품질을 좀 더 개선할 수 있는 방법이 또 있다. 이번년도 <em>I3D</em> 에 제출된 <em>Alpha Distribution</em> 이라는 논문이 있는데, 이는 <em>Hashed Alpha Testing</em> 처럼 런타임에 계산을 하지않고 각 <em>Mip-level</em> 의 텍스쳐를 미리 처리해놓는 방법 중에 하나다. 미리 계산된 <em>Texture</em> 들을 사용하여 일반적인 <em>Alpha Test</em> 를 그대로 사용하기만 하면 된다. 아직 직접 사용한 예시는 없어 검증되지는 않았지만, 이 방법이 그대로 사용될 수 있다면 <em>Alpha Test</em> 부분에서는 거의 끝판왕이 될 것 같다.</p>

<p><em>Alpha Distribution</em> 일반적인 <em>Alpha Test</em> 를 기준으로 <em>Alpha Threshold</em> 가 고정되어 있다는 것을 가정한다. 그렇게 되면 <em>Alpha Threshold</em> 에 따라서 픽셀에 출력이 되냐, 안되냐로  따질 수가 있다.(<em>Binary Visibility</em>) <em>Binary Visibility</em> 를 각 <em>Mip-level</em> 에 맞춰서 고르게 분산(<em>Distribution</em>)시키는게 <em>Alpha Distribution</em> 의 목적이다.</p>

<p><em>Alpha Distribution</em> 은 두가지 분산방법을 사용한다. <em>Error Diffusion</em> 과 <em>Alpha Pyramid</em> 이라는 방법을 사용한다. 하나씩 알아보자.</p>

<p><em>Error Diffusion</em> 은 하나하나의 픽셀을 순회하면서, 각 픽셀의 <em>Binary Visibility</em> 에 해당하는 값(0 아니면 1)과 이미지가 가지고 있는 <em>Alpha</em> 값을 비교해 그 오차(<em>Quantization Error</em>)를 다른 픽셀에 나누어준다. <em>Binary Visibility</em> 는 다음과 같이 정해진다.</p>

<blockquote>
  <p>αˆi = αi &gt;= ατ : 1, αi &lt; ατ : 0</p>
</blockquote>

<p>αi 는 이미지가 가지고 있는 이산화된 <em>Alpha</em> 값이고, ατ 는 <em>Alpha Threshold</em>, 한계값을 뜻한다. αˆi 는 해당 픽셀의 <em>Binary Visibility</em> 를 뜻한다. 이것을 가지고 <em>Quantization Error</em> 를 계산한다.</p>

<blockquote>
  <p>ϵi = αi − αˆi</p>
</blockquote>

<p>ϵi 는 <em>Quantization Error</em> 를 뜻하고 픽셀이 보이게 된다면 <em>~1 &lt;= ϵi &lt; 0</em> 의 값을 가지게 되고 픽셀이 보이지 않는다면 <em>0 &lt; ϵi &lt;= 1</em> 의 값을 가지게 된다. 이런 <em>Quantization Error</em> 는 인근 픽셀로 분포된다. 아래 그림을 보자.</p>

<p><img src="/images/ad_error_diffusion.png" alt="Error Diffusion" class="center-image" /></p>

<p>그림에서 ϵi 가 들어가 있는 부분이 현재 처리중인 픽셀이며, ϵi 의 값은 인근 픽셀로 고정된 비율로 <em>Alpha</em> 값에 더해진다. (x+1,y) 는 7/16, (x-1,y+1) 은 3/16, (x,y+1) 은 5/16, (x+1,y+1) 은 1/16 비율로 분포된다. 이런 방법으로 각 픽셀을 순회하면서 처리하면 <em>Error Diffusion</em> 은 간단하게 끝난다. 오차 확산이라는 이름이 굉장히 직관적이다.</p>

<p><em>Error Diffusion</em> 은 픽셀과 픽셀사이의 <em>Alpha</em> 값을 고르게 분포시킨다. 하지만 약간의 문제가 존재한다. 보이게 되던, 안보이게 되던 <em>Alpha</em> 값이 0.3 ~ 0.7 정도로 중간값을 가지고 있다면, 한 픽셀은 강조되고, 옆의 픽셀은 보이지 않게 된다. 이러한 방법은 아래 이미지와 비슷한 결과를 만든다.</p>

<p><br />
![Michelangelo’s_David_-<em>Floyd-Steinberg](/images/Michelangelo’s_David</em>-_Floyd-Steinberg.png){: .center-image}</p>
<center>출처 : <a href="https://en.wikipedia.org/wiki/Dither">Wikipedia : Dither</a>
</center>
<p><br /></p>

<p><em>Error Diffusion</em> 의 문제는 위 그림처럼 비슷한 색 영역에 있어도 분산된 영향을 받아서 각 픽셀이 부드럽게 보이지 않는 현상이 발생한다. 이러한 특징을 <em>Dithering</em> 이라고 부른다. 그래서 <em>Alpha Distribution</em> 논문에서는 이보다 나은 품질을 위해 <em>Alpha Pyramid</em> 라는 다른 방법이 소개된다.</p>

<p><br />
<img src="/images/alpha_pyramid.png" alt="Cemyuksel : Alpha Distribution" class="center-image" /></p>
<center>출처 : <a href="http://www.cemyuksel.com/research/alphadistribution/">Cemyuksel : Alpha Distribution</a>
</center>
<p><br /></p>

<p><em>Alpha Pyramid</em> 은 <em>Error Diffusion</em> 보다는 좀 더 복잡한 방식이다. <em>Alpha Pyramid</em> 라는 밉맵같은 개념의 텍스쳐들을 생성하고, 그 <em>Alpha Pyramid</em> 를 사용해서 <em>Alpha</em> 값들을 분산시키는 방법이다. <em>Alpha Pyramid</em> 를 만들고 값을 다루는 방법에 대해서 알아보자.</p>

<p><em>Alpha Pyramid</em> 은 각각의 <em>mip-level</em> 마다 하나씩 생성된다. 즉 이미지 한개씩만 처리한다.</p>

<p><em>Alpha Pyramid</em> 를 만들떄 맨 처음에 <em>Mip-Map</em> 과 비슷한 방식으로 <em>Sub-level</em> 들을 만든다. 맨 처음에 생성되는 <em>level</em> 의 해상도는 이미지 해상도의 1/4(1/2*1/2) 을 곱한 해상도로, 2의 지수가 아니여도 된다. 이렇게 생성된 <em>level 1</em> 은 약 원본 이미지의 해상도가 1/4이 되는데, <em>level 0</em> 의 각 픽셀들에 적어도 원본 이미지의 픽셀 4개의 알파값들을 더해서 저장한다. 원본 이미지의 해상도가 2의 지수가 아니라면 <em>level 0</em> 세로와 가로 끝부분의 픽셀들은 픽셀 6개의 알파값들을 더해서 저장하고, 가장 모서리의 픽셀 하나는 픽셀 9개의 알파값을 더해서 저장한다. 위의 이미지는 그리드로 원본의 해상도를 표시하고, 색으로 해당 레벨의 실질적인 픽셀들을 표시한다.</p>

<p>원본 이미지와 <em>level 1</em> 의 관계는 <em>level 1</em> 생성한 후 다음 <em>Level 2</em> 을 생성할 때 <em>level 1</em> 과 <em>level 2</em> 의 관계와 같다. 즉 같은 방법을 2x2 해상도가 될떄까지 계속 반복한다. 이렇게 생성된 <em>Alpha Pyramid</em> 의 각 레벨의 텍셀은 하위 레벨의 연관된 <em>Alpha</em> 값들의 합을 가지고 있는다. 이를 누적된 알파값(<em>Accumulated Alpha</em>)라고 부르겠다.</p>

<p>다음은 각각의 <em>Accumulated Alpha</em> 을 가지고 각각의 픽셀의 보여주는 여부를 결정하는 <em>Visibility Value</em> 를 구해야 한다. 처음에는 <em>Alpha Pyramid</em> 의 최상위 레벨의 각각의 <em>Accumulated Alpha</em> 값들의 합을 구하여 올림을 해준 값을 가지고 있는다. (이 값은 입력으로 들어온 이미지의 보여지는 픽셀을 정하는 값으로, 이 값이 하위 층으로 한층한층 분산되면서 결국 이미지의 보여지는 픽셀을 결정하게 된다. 논문에서는 텍스쳐 전체의 <em>Visibility Value</em> 라고도 한다.) <em>Alpha Pyramid</em> 의 최상위 레벨의 각각의 <em>Accumulated Alpha</em> 의 정수부의 값만(일반적으로 <em>Alpha</em> 값은 0 ~ 1 사이의 소수.) <em>Visibility Value</em> 에 저장한다. 그리고 각 <em>Accumulated Alpha</em> 의 소수부 값들 중 큰 값들만 <em>Visibility Value</em> 를 1씩 나누어준다. 이러면 모든 <em>Visibility Value</em> 가 분산된다. 이렇게 최상위 층의 처리가 끝난다.</p>

<p>그 다음 각각의 층들이 처리가 되야한다. 최상위 층은 각 <em>Accumulated Alpha</em> 을 가지고 있는 윗층이 없어 직접 구했지만, 아랫층부터는 상위 층들이 <em>Accumulated Alpha</em> 합을 구해서 가지고 있다. 이 값을 가지고 위에서 언급한 <em>Visibility Value</em> 를 계산하여 계속 구한다. <em>level 1</em> 까지 이 과정을 반복하면 <em>Alpha Pyramid</em> 내부에서 처리하는 과정은 끝난다.</p>

<p>다음은 마지막으로 계산된 <em>Alpha Pyramid</em> 의 최하층 <em>level 1</em> 의 <em>Visibility Value</em> 들과 맨 처음 입력으로 들어온 이미지를 처리한다. (위에서 <em>Binary Visibility</em> 에 대한 언급을 했었다. <em>Alpha Test</em> 의 이미지는 결국 보이냐, 안보이냐의 차이이기 때문에 <em>Alpha Pyramid</em> 도 <em>level 1</em> 의 <em>Visibility Value</em> 를 통해 이미지의 <em>Binary Visibility</em> 를 처리해준다.) <em>level 1</em> 에 관련된 2x2,2x3,3x2,3x3 픽셀의 <em>Binary Visibility</em> 를 처리한다. <em>level 1</em> 의  <em>Visibility Value</em> 의 값을 기존 이미지가 가지고 있는 <em>Alpha</em> 값이 큰 순서대로 1씩 나누어준다.(보이게 처리한다.) 그렇게 <em>Visibility Value</em> 를 다 쓰게되고 남아있는 픽셀들은 안보이게 처리한다.</p>

<p><em>Alpha Pyramid</em> 는 순서대로 텍스쳐의 층을 쌓은 후 최상층에서 다시 차례대로 내려오면서 <em>Visibility Value</em> 를 분산시키고, 마지막으로 이미지의 각 픽셀의 <em>Binary Visibility</em> 를 정해주는 방법이다.</p>

<p>이 글에서의 <em>Alpha Distribution</em> 에 대한 내용은 논문 뿐만 아니라 논문의 저자가 제공한 코드까지 참조하여 썼다. 근데 논문의 내용중 여기서 언급하지 않은 내용이 있다. 저자가 <a href="https://github.com/cemyuksel/cyCodeBase/blob/master/cyAlphaDistribution.h">제공한 코드</a>에서는 <em>Visibility Value</em> 를 분산시킬 떄 소수부의 값이 큰 기준으로 분산시킨다. 하지만 논문에서는 이를 랜덤하게 처리한다고 한다. 왜냐하면 균일한 패턴의 생성을 막기 위해서라고 한다. 하지만 제공되는 코드에서는 랜덤하게 설정하는 부분은 없었다. 또한 코드에서는 <em>Alpha Threshold</em> 를 0.5 로 가정하여 코드를 짜놓아서</p>

<p>방법만 봐도 여러가지 이유로 <em>Alpha Pyramid</em> 이 <em>Error Diffusion</em> 보다는 더 나은 <em>Alpha Test</em> 를 제공할 것 같다는 생각이 든다. 논문에서도 실제로 더 나은 품질을 보여준다고 한다.</p>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">    <iframe title="YouTube video player" width="640" height="390" src="//www.youtube.com/embed/cjHfPi9lQik" frameborder="0" allowfullscreen=""></iframe></div>

<p>절대적으로 좋은 결과를 내게하는 방법은 없다. <em>Alpha Distribution</em> 역시 단점을 가지고 있다. 미리 처리를 하기 때문에 이미지가 고정되어 타일링처럼 보일 수가 있다. 또한 확대시 아무것도 처리하지 않고, <em>Bilinear Filtering</em> 만 걸은 것보다 안좋은 결과를 보여줄 수도 있다.</p>

<p><br />
<img src="/images/ad_cons.png" alt="Cemyuksel : Alpha Distribution" class="center-image" /></p>
<center>출처 : <a href="http://www.cemyuksel.com/research/alphadistribution/">Cemyuksel : Alpha Distribution</a>
</center>
<p><br /></p>

<p>또 <em>Alpha Threshold</em> 가 고정되어 있다고 가정하기 때문에 값이 바뀌면 다시 계산해야한다. 직접 구현해서 붙이는 경우에는 계산하는 코드를 넣어주어야 하는데, 만약 <em>Texture Compression</em> 이 적용되어 있으면 굉장히 귀찮을 것이다. 거기에 상용엔진에 <em>Intergration</em> 할려면 더욱더 심할것이다.</p>

<p>그에 비해 <em>Hashed Alpha Testing</em> 은 구현하기엔 쉬운편이다. 코드는 <em>Shader</em> 에 붙여넣기만 하면 된다. 하지만 약간의 퍼포먼스를 잡아먹고, 뭉개진 가루처럼 보이는 현상이 존재하기 때문에 무조건 좋다고하기에는 무리가 있다.</p>

<p>조금더 시간을 가지고 지켜봐야 될것 같다는 생각이 든다.</p>
      <h2>
        
        
          참조
        
        
      </h2>
    

<ul>
  <li><a href="https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">Anti-aliased Alpha Test: The Esoteric Alpha To Coverage</a></li>
  <li><a href="https://developer.download.nvidia.com/assets/gameworks/downloads/regular/GDC17/RealTimeRenderingAdvances_HashedAlphaTesting_GDC2017_FINAL.pdf?pUIX8DXxfad7mL4zB3GOthX3r5IgGao9UWxYuYb3q9h10RXrQeYko-dEuJXJxt1hhsI9J_9KJDcCYGeWWksxlaHTrXSE825D_3izja7LUFOtzhaeBUqpn7qbwXaaGlLdbipjE3PeI3e2IMn45mQAA3OV2PD-kG2y9cecTaWE2uum2uwdHgyn0nhYiLOvlOsrUzewbK5REH7vAm3-lNWzxehw_5Tphg">NVidia developer : Hashed Alpha Testing</a></li>
  <li><a href="http://cwyman.org/papers/tvcg17_hashedAlphaExtended.pdf">Cwyman.org : Hashed Alpha Test(Extended)</a></li>
  <li><a href="http://www.cemyuksel.com/research/alphadistribution/">Cemyuksel : Alpha Distribution</a></li>
  <li><a href="https://github.com/cemyuksel/cyCodeBase/blob/master/cyAlphaDistribution.h">Github : cyAlphaDistribution.h</a></li>
</ul>

  </div>

  
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://suhyeokkim-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</article>

      </div>
    </main>
    
    <script>
      $("script[type='math/tex']").replaceWith(function() {
          var tex = $(this).text();
          return katex.renderToString(tex, {displayMode: false});
      });

      $("script[type='math/tex; mode=display']").replaceWith(function() {
          var tex = $(this).html();
          return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
      });
    </script>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2022 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://suhyeokkim.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
