<!DOCTYPE html>
<html lang="ko">

  <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG"></script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Frustum Traced Shadow With Irrelgular Z Buffer 0</title>
  <meta name="description" content="Percentage-Closer Filtering Shadows 에서 PCF 를 응용한 PCSS 라는 Soft Shadow 를 나타내는 기법에 대해서 알아보았다. 이번 글에서는 여태까지 알아본 것들에 비해 굉장히 최근에 나온 기법인 frustum-Traced Shadow 에 대해서 알아볼것이다.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://suhyeokkim.github.io/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-0">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://suhyeokkim.github.io/feed.xml">

  <meta name="google-site-verification" content="o3-a11YI0ZIYwUdcikrWBRObGOUHzk89IJF7CX0ieQk" />

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Frustum Traced Shadow With Irrelgular Z Buffer 0">
  <meta name="twitter:description" content="Percentage-Closer Filtering Shadows 에서 PCF 를 응용한 PCSS 라는 Soft Shadow 를 나타내는 기법에 대해서 알아보았다. 이번 글에서는 여태까지 알아본 것들에 비해 굉장히 최근에 나온 기법인 frustum-Traced Shadow 에 대해서 알아볼것이다.">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Frustum Traced Shadow With Irrelgular Z Buffer 0</h1>
    
    <p class="post-meta"><time datetime="2018-01-13T00:00:00+00:00" itemprop="datePublished">Jan 13, 2018</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Su-Hyeok Kim</span></span> • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/fts/">fts</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="/2017/12/27/percentage-closer-soft-shadows">Percentage-Closer Filtering Shadows</a> 에서 <em>PCF</em> 를 응용한 <em>PCSS</em> 라는 <em>Soft Shadow</em> 를 나타내는 기법에 대해서 알아보았다. 이번 글에서는 여태까지 알아본 것들에 비해 굉장히 최근에 나온 기법인 <em>frustum-Traced Shadow</em> 에 대해서 알아볼것이다.</p>

<!-- more -->

<p>해당 기법은 2015년에 <em>Siggraph</em>, <em>Interactive 3D</em> 같은 컨퍼런스에서 발표되었으며, 현재 <em>Tom Clansy’s the Division</em> 에 <em>PCSS</em> 와 혼합된 형태(<em>Hybrid frustum Traced Shadow</em>)로 적용되어 있다. <em>Frame Rate</em> 에 조금 영향을 미쳐 대부분의 게이머들은 아직은 <em>HFTS</em> 를 사용하지 않는듯 하다.(<a href="https://www.reddit.com/r/nvidia/comments/49idz3/nvidia_hfts_the_division/">Reddit : Nvidia HFTS (The Division)</a>) 하지만 컴퓨팅 파워가 늘어나는 것을 가정한다면 앞으로 하이엔드 게임의 주 옵션이 될수도 있겠다.</p>

<p>이 기법의 저자는 <em>Shadow Map</em> 처럼 따로 붙은 기법없이 <em>Aliasing</em> 이 없어야 했으며, 현세대의 GPU 와 해상도를 <em>Interactive</em> 하게 지원하는 것이 완벽한 <em>Hard Shadow</em> 를 목표로 <em>FTS</em> 를 고안했다. 가장 많이 쓰이는 <em>Shadow Map</em> 기법은 공간적(<em>Light-Space</em> 와 <em>Clipping-Space</em> 의 <em>Discretize</em> 된 결과의 차이), 일시적인(필터링이 필요한 <em>Aliasing</em>)인 문제들이 산재한다. 이는 이 기법을 고안한 시발점이였다.</p>

<p><em>FTS</em> 의 이론적인 뿌리를 정하기 위해 저자는 여태까지 존재하는 여러 기법을 언급한다. 빛을 하나의 직선단위로 시뮬레이팅 하는 <em>Ray-Tracing</em>, 볼륨을 통한 각각의 폴리곤들을 테스트 하는 <em>Shadow Volume</em>, <em>Irregular Z-Buffers</em> 를 언급했다.</p>

<p><em>Shadow Volume</em> 은 3차원상으로 <em>Shadow</em> 가 생기는 부분을 정해 그 부분을 테스트해서 <em>Shadow</em> 를 정해주는 기법이다. 이는 <em>Shadow Map</em> 보다 픽셀 단위로 처리할 수 있지만, 여러 단점이 있다고 한다. 한번에 해결되는 깔끔한 방법이 없으며, 보이지 않는 부분도 처리하기 때문에 <em>Fill-Rate</em> 를 많이 소모한다. 게다가 처리 자체가 간단하지 않기 때문에 개발자들도 많이 쓰는 기법이 아니라고 한다. 필자도 <em>Shadow Map</em> 에 대한 자료는 굉장히 많이 봤지만 <em>Shadow Volume</em> 은 거의 본적이 없다.</p>

<p><br /></p>

<p><img src="/images/NVidia_ShadowVolume.jpg" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch09.html">GPU Gems : Efficient Shadow Volume Rendering</a>
</center>
<p><br /></p>

<p><em>Ray-Tracing</em> 은 빛을 직선 단위로 시뮬레이팅을 하는 기법으로, 계산 비용 자체가 비싸기 때문에 하드웨어와 구조에 굉장히 의존적이라고 한다. 게임에서도 쓰일 수 있는 기법이 있었지만 다른 후보에 밀려났다. 바로 <em>Irregular Z-Buffer</em> 다. 현대 GPU 의 <em>Geometry</em> -&gt; <em>Rasterize</em> 구조에 맞춰 가장 걸맞는 방법이라고 한다. 자세한 설명은 아래에서 보자.</p>
      <h3>
        
        
          Key Idea
        
        
      </h3>
    

<p>이 기법의 중요한 아이디어는 앞에서 소개한 <em>Irregular Z-Buffer</em> 와 <em>frustum-Triangle Test</em> 이 두가지다. <em>Irregular Z-Buffer</em> 는 앞서 <em>Shadow Map</em> 의 단점중에 공간적 괴리를 해결하는 데이터 구조이고, <em>frustum-Triangle Test</em> 는 논문에서 한 말을 이용하면 <em>Sub-Pixel Accurate Pixel</em> 을 구성하기 위한 시뮬레이션 테스트다. 이 두가지를 간단하게 살펴보자.</p>

<p>첫번째로는 바로 위에서 언급했던 <em>Irregular Z-Buffer</em> 다. 여기서의 <em>IZB</em> 는 우리가 알던 일반적인 <em>Buffer</em> 의 쓰임새와는 조금 다르게 쓰인다. 이 기법에서의 <em>IZB</em> 는 일반적인 <em>Shadow Map</em> 에서의 <em>Eye-Space</em> 와 <em>Light-Space</em> 의 괴리를 없에기 위해 <em>Light-Space</em> 를 기준으로 <em>Depth</em> 를 쭉 저장하는게 아닌, <em>Eye-Space</em> 의 각각 픽셀별로 표현하는 물체에 영향을 미치는 광원을 방향으로 <em>Ray</em> 를 쏜다. 그리고 <em>Light-Space</em> 를 기준으로 만든 <em>Grid</em> 버퍼에 <em>Ray</em> 가 부딫치고, 부딫친 부분에서 가장 가까운 텍셀에 데이터를 저장한다. 위에서 설명한 <em>IZB</em> 를 구성하는 방법에 대한 그림이 아래에 있다.</p>

<p><br />
<img src="/images/fts_IZB.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>간단하게 이런식으로 <em>IZB</em> 가 구성되는 것을 알 수 있다. 이제 <em>Geometry</em> 와 비교하는 <em>Visibility Test</em> 가 필요하다. 일반적인 <em>Shadow Mapping</em> 의 <em>Visibility Test</em> 와는 조금 다르다. 기존의 <em>Shadow Mapping</em> 은 정점을 <em>Light-Space</em> 로 바꾸어 <em>Z</em> 값을 비교하여 <em>Visibility Test</em> 를 한다. 하지만 이 기법에서의 <em>Visibility Test</em> 는 다르다. 위에서 언급한 것과 같이 <em>IZB</em> 를 만든다. 그 다음 <em>Occlluder Geometry</em> 들을 <em>Light-Space</em> 를 기준으로 <em>Conservative Rasterization</em> 을 해준다.<sup id="fnref:C1" role="doc-noteref"><a href="#fn:C1" class="footnote">1</a></sup> 그렇게 나온 결과를 통해 <em>IZB</em> 와 함께 <em>Visibility Test</em> 를 한다. <em>Conservative Rasterization</em> 의 결과는 거의 <em>Flag</em> 로 사용될것으로 예측되고, <em>Eye-Space</em> 픽셀의 그림자 계산은 복잡한 계산을 통해 구한다. 아래는 논문에 있던 <em>IZB</em> 를 기준으로 쓰여진 수도 코드다.</p>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Step 1: Identify pixel locations we need to shadow
G(x, y) ← RenderGBufferFromEye()

// Step 2: Add pixels to our light-space IZB data structure
for pixel p ∈ G(x, y) do
    lsTexelp ← ShadowMapXform[ GetEyeSpacePos( p ) ]
    izbNodep ← CreateIZBNode[ p ]
    AddNodeToLightSpaceList[ lsTexelp, izbNodep ]
end for

// Step 3: Test each triangle with pixels in lists it covers
for tri t ∈ SceneTriangles do
    for frag f ∈ ConservateLightSpaceRaster( t ) do
        lsTexelf ← FragmentLocationInRasterGrid[ f ]
        for node n ∈ IZBNodeList( lsTexelf ) do
            p ← GetEyeSpacePixel( n )
            visMask[p] = visMask[p] | TestVisibility[ p, t ]
        end for
    end for
end for
</code></pre></div></div>

<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>다음은 <em>Visibility Test</em> 다. 논문에서는 <em>frustum-Triangle Test</em> 라고 부르는데, 이는 조금 복잡한 과정으로 구성된다. 아래 그림을 보면서 알아보자.</p>

<p><br />
<img src="/images/fts_VisibilityTest.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>가장 처음에는 <em>μQuad</em> 라는 것을 생성한다. <em>μQuad</em> 는 <em>Tangent-Space</em> 를 기준으로 설정하며 각 픽셀별로 생성한다. 위 그림에서는 중간 그림에 구 위에있는 평면을 뜻한다. 그 다음 가리는 <em>Geometry</em> 의 폴리곤들의 각각의 <em>Edge</em> 를 사용하여 <em>Shadow Plane</em> 을 생성한다. 마지막으로 만들어진 <em>Shadow Plane</em> 을 <em>μQuad</em> 에 <em>Projection</em> 한다. 이때 가지고 있던 <em>LUT</em> 를 통해 가려짐을 계산한다. 그리고 다른 <em>Edge</em> 들도 계속해서 누적시킨다.</p>

<p>간단하게 <em>frustum-Triangle Test</em> 의 단계에 대해 설명해보았다. 이제 각각의 과정 : <em>μQuad Construction</em>, <em>Shadow Plane Construction</em>, <em>Visibility Computation</em> 에 대해 조금 더 자세히 써보겠다.</p>

<p><em>μQuad</em> 의 생성은 <em>Geometry</em> 의 <em>Tangent-Space</em> 를 기준으로 계산되는 것 빼고는 특이한 점이 없다. 하지만 생성되는 시기에 대해선 조금 특별한게 있다. 가시성을 계산할 때 생성할 수도 있지만 <em>G-Buffer</em> 를 생성할 때 미리 계산하는 것이 더 효율적이라고 한다.</p>

<p>가시성을 계산할 때 <em>ray-triangle intersection</em> 을 계산하기 보다는 앖에서 언급한 각각의 폴리곤의 <em>Shadow Volume</em> 을 각 점마다 계산한다고 한다. <em>Shadow Volume</em> 은 그림자를 생성하는 <em>Occluder Triangle</em> 을 기준으로 각각의 <em>Edge</em> 에서 뻗어나오는 직사각형 면으로 구성된다. 아래 그림을 보면 쉽게 이해할 수 있다. 그리고 <em>μQuad</em> 에서 샘플링한 각각의 점들을 기준으로 가시성을 계산한다면 한다면, 4번의 내적으로 가시성을 테스트할 수 있다는 것을 의미한다.</p>

<p><br />
<img src="/images/HFTS_frustumTracing.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://developer.download.nvidia.com/gameworks/events/  GDC2016/jstory_hfts.pdf">NVidia : Advanced Geometrically Correct Shadows for Modern Game Engines</a>
</center>
<p><br /></p>

<p>또한 그림자를 멀티샘플링 하기 위해서는 여기서 언급한 <em>Shadow Volume</em> 의 <em>Shadow Plane</em> 들을 이용한다고 한다.</p>

<p>마지막으로 <em>Visibility Computation</em> 이 남아있다. 이 부분의 대략적인 것은 위에서 언급했다. 자세한 계산방식을 말해보겠다. 위에서 언급한 <em>μQuad</em> 와 <em>Shadow Plane</em> 사용해서 해당 폴리곤들의 데이터 누적을 위해서는 <em>μQuad</em> 에서 이산화된 <em>binary</em> 샘플링이 필요하다. 논문의 저자는 32 번의 <em>Halton sampling</em><sup id="fnref:C2" role="doc-noteref"><a href="#fn:C2" class="footnote">2</a></sup> 을 사용했다고 한다.</p>

<p>가시성을 계산하기 위해서는 <em>Shadow Plane</em> 을 <em>μQuad</em> 에 <em>Projection</em> 해줘야 한다. 그러면 <em>μQuad</em> 는 최대 3개의 <em>line</em> 을 얻게 된다. 논문에서는 이 <em>line</em> 을 <em>μQuad</em> 를 기준으로 극좌표계<sup id="fnref:C3" role="doc-noteref"><a href="#fn:C3" class="footnote">3</a></sup> 데이터로 저장한다고 한다. 반지름과 각도가 5bit 크기로 저장된다. 해당 10bit 데이터를 사용하여 미리 계산된 테이블에서 32개의 이진 가시성 샘플을 가져온다. 결과와  bit 단위의 and 연산을 통해 <em>μQuad</em> 의 가시성을 계산할 수 있다고 한다.</p>

<p>해당 기법을 고안한 사람은 두가지의 아이디어 : <em>Irregular Z-Buffer</em> 와 <em>frustum-Triangle Test</em> 를 통해  <em>Sub-pixel Hard Shadow</em> 의 이론을 만들었다. 하지만 이 아이디어들과 구현을 위한 노력의 차이는 꽤 큰듯하다. 논문을 보면 아이디어에 대한 텍스트보다 최적화를 위한 텍스트가 2배가 될정도로 많다. 다음 글에서는 논문에서 나온 전체 과정과 디테일한 구현 사항에 대해 적어보겠다.</p>
      <h2>
        
        
          참조
        
        
      </h2>
    

<ul>
  <li><a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Irregular_Z-buffer">Wikipedia : Irregular Z-Buffer</a></li>
  <li><a href="http://cwyman.org/videos/sig1657-chris-wyman-magic-behind-gameworks-hybrid-frustum-traced-shadows-hfts.mp4">cywman.org : HFTS Presentation Video</a></li>
  <li><a href="https://developer.nvidia.com/content/dont-be-conservative-conservative-rasterization">NVidia : Don’t be conservative with Conservative Rasterization</a></li>
  <li><a href="http://developer.download.nvidia.com/gameworks/events/GDC2016/jstory_hfts.pdf">NVidia : Advanced Geometrically Correct Shadows for Modern Game Engines</a></li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:C1" role="doc-endnote">
      <p>일반적으로 오브젝트를 그리는 것과 다른 <em>Conservative Rasterization</em> 을 해주는 이유는 일반적인 <em>Rasterization</em> 은 픽셀의 반이상을 차지해야 해당 픽셀을 처리해준다. 하지만 정확한 <em>Visibility</em> 를 계산하기 위해서는 폴리곤이 해당되는 모든 픽셀들을 처리해주어야 한다. <em>Conservative Rasterization</em> 은 앞에서 말한바와 같이 모든 부분을 픽셀로 처리한다. <em>Conservative Rasterization</em> 에 대한 자세한 정보는 <a href="https://developer.nvidia.com/content/dont-be-conservative-conservative-rasterization">NVidia : Don’t be conservative with Conservative Rasterization</a> 에서 확인할 수 있다. <a href="#fnref:C1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:C2" role="doc-endnote">
      <p>몬테카를로 시뮬레이션과 같은 방식의 점을 생성하는 방식이다. 쉽게 말하면 랜덤하게 생성하는 것이라고 생각하면 된다. 자세한 정보는 <a href="https://en.wikipedia.org/wiki/Halton_sequence">Wikipedia : Halton sequence</a> 에서 확인할 수 있다. <a href="#fnref:C2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:C3" role="doc-endnote">
      <p>여기서는 각도와 반지름(거리)를 사용하여 나나탠다. 극좌표계에 대한 자세한 정보는 <a href="https://ko.wikipedia.org/wiki/%EA%B7%B9%EC%A2%8C%ED%91%9C%EA%B3%84">위키피디아 : 극좌표계</a> 에서 확인할 수 있다. <a href="#fnref:C3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://suhyeokkim-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</article>

      </div>
    </main>
    
    <script>
      $("script[type='math/tex']").replaceWith(function() {
          var tex = $(this).text();
          return katex.renderToString(tex, {displayMode: false});
      });

      $("script[type='math/tex; mode=display']").replaceWith(function() {
          var tex = $(this).html();
          return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
      });
    </script>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2022 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://suhyeokkim.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
