<!DOCTYPE html>
<html lang="ko">

  <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG"></script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Frustum Traced Shadow With Irrelgular Z Buffer 2</title>
  <meta name="description" content="frustum Traced Shadow with Irregular Z-Buffer 1 에서 포괄적인 전체 시스템과 복잡도에 대하여 알아보았다. 이번 글에서는 시스템 구현에 관한 디테일한 사항들을 알아볼 것이다.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/2018/01/14/frustum-traced-shadow-with-irrelgular-z-buffer-2">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="o3-a11YI0ZIYwUdcikrWBRObGOUHzk89IJF7CX0ieQk" />

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Frustum Traced Shadow With Irrelgular Z Buffer 2">
  <meta name="twitter:description" content="frustum Traced Shadow with Irregular Z-Buffer 1 에서 포괄적인 전체 시스템과 복잡도에 대하여 알아보았다. 이번 글에서는 시스템 구현에 관한 디테일한 사항들을 알아볼 것이다.">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Frustum Traced Shadow With Irrelgular Z Buffer 2</h1>
    
    <p class="post-meta"><time datetime="2018-01-14T00:00:00+00:00" itemprop="datePublished">Jan 14, 2018</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Su-Hyeok Kim</span></span> • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/fts/">fts</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="/2018/01/13/frustum-traced-shadow-with-irrelgular-z-buffer-1">frustum Traced Shadow with Irregular Z-Buffer 1</a> 에서 포괄적인 전체 시스템과 복잡도에 대하여 알아보았다. 이번 글에서는 시스템 구현에 관한 디테일한 사항들을 알아볼 것이다.</p>

<!-- more -->

<p>첫번째로는 <em>Irregular Z-Buffer</em> 와 <em>Sampling Rate</em> 간의 최적화다. 논문의 저자는 기본적으로 <em>32spp</em> (<em>sampling per pixel</em>) 를 제안했다. 정확히 짚자면, <em>Light-Space</em> 에서 <em>Occluder Geometry</em> 를 <em>Conservative Rasterization</em> 을 하면 <em>Visibility Test</em> 를 계산하는 것이, 한번 <em>Visibility Test</em> 를 할때 32번을 하는게 가장 신경쓰이는 부분이다. 이의 결과를 저장하기 위해 두가지 방법이 있다고 한다. 하나는 <em>μQuad</em> 를 <em>Light-Space</em> 에서 <em>IZB</em> 를 만들 떄 <em>Rasterize</em> 하는 것, 다른 방법은 32 번의 <em>Visibility Test</em> 샘플링 결과를 <em>IZB</em> 에 저장하는 것이다. 전자는 비용이 크기 때문에 안쓰고, 후자를 선택했다고 한다. 이를 <em>Sample-based insertion</em> 이라고 명명했다. 그래서 이 방식으로 <em>Prototype</em> 을 만들어 보니, <em>IZB</em> 의 중복을 위한 최적화를 했음에도 불구하고 한 픽셀당 8개 이상의 <em>IZB Node</em> 가 생성되었다고 한다.</p>

<p>그래서 고안해낸 간단한 근사(<em>approximate</em>)하는 방법을 언급한다. <em>μQuad</em> 의 <em>Normal</em> 벡터와 <em>View Ray</em>(<em>Eye Direction</em>) 벡터의 내적 값이 0에 가까워질수록(90도에 가까워질수록) <em>μQuad</em> 를 늘리는 것이다. 아래 그림의 왼쪽 그림을 보면 쉽게 이해할 수 있다.
그래서 고안해낸 간단한 근사(<em>approximate</em>)하는 방법을 언급한다. <em>μQuad</em> 의 <em>Normal</em> 벡터와 <em>View Ray</em>(<em>Eye Direction</em>) 벡터의 내적 값이 0에 가까워질수록(90도에 가까워질수록) <em>μQuad</em> 를 늘리는 것이다. 아래 그림의 왼쪽 그림을 보면 쉽게 이해할 수 있다.</p>

<p><br />
<img src="/images/fts_microquad_elongate.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>보다 정확하게 계산 방법을 설명하자면, <em>μQuad</em> 의 넓이는 표면의 방향과 상관없이 상수로 정해주고 <em>View Ray</em> 의 앞뒤 방향으로 <em>μQuad</em> 의 길이가 늘어나고, 그 방향을 따라서 1줄로 샘플링을 한다. 1차원이라고도 할 수 있겠다. 1 ~ 8 개의 샘플링을 해준다고한다. 위 그림의 오른쪽 그림을 보면 쉽게 이해할 수 있다.</p>

<p>다만 이는 단지 <em>Irregular Z-Buffer</em> 를 <em>Approximate</em>(근사) 하는 것이기 때문에 오차가 생길 수 있다. <em>μQuad</em> 가 커질수록 <em>IZB Node</em> 를 넣는 것을 놓치고, <em>Light Leak</em> 을 발생시킬 수 있다. 보통 가리는 물체가 작거나, 멀리있는 경우에 해당된다. <em>Light Leak</em> 을 없에는 방법은 몇가지가 존재하는데, 가장 쉬운 방법은 <em>IZB</em> 의 기본적인 모토인 1:1 샘플링을 맞춰주는 것이다. 하지만 이는 정확히 해주기에 어려운 경우가 있다고 한다. 그래서 다른 방법을 제시한다. <em>Conservative Rasterization</em> 은 보통 결과에서 0.5 픽셀을 늘려준다. 하지만 1 픽셀 팽창(<em>dilation</em>)을 해주는 <em>Conservative Rasterization</em> 을 사용하면 <em>Light Leak</em> 을 막을 수 있다. 원래 <em>μQuad</em> 2차원으로 샘플링을 했었으나 기준을 1차원으로 줄이면서 각각의 폴리곤의 넓이을 늘리는 방식으로 보완한 것이라고 생각하면 되겠다. 아래 그림에 적용을 한 사례가 있다.</p>

<p><br />
<img src="/images/fts_approx-insert_vs_over-conserv-raster.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>이전 글에서 언급한 복잡도는 O(<em>La</em> * <em>F</em>) 이다. 우선 평균적인 리스트의 길이는 줄어든다고 한다. 샘플링을 하는 횟수가 최소 1/4 정도 줄었기 때문이다.(8 / 32) 그리고 더 넓은 <em>Conservative Rasterization</em> 의 결과로 <em>Fragment</em> 의 갯수는 최대 60% 증가했다고 한다. 이는 성능상 엄청난 이득을 가져온다.</p>

<p>하지만 이 방법은 <em>Approximate</em> 하는 방법이란 것을 알아야 한다. 아주 극성맞은 경우와 안좋은 파라미터 설정에는 <em>Light Leak</em> 이 발생할 수 있다고 한다. 아래 그림에서 그 경우를 볼 수 있다.</p>

<p><br />
<img src="/images/fts_lightleaks.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>왼쪽의 그림은 정상적으로 그림자가 보일 때, 두번째는 정말 안좋은 경우들이 겹친 <em>Light Leak</em> 이 발생하는 경우, 세번째 경우는 세팅값을 맞춰주어 <em>Light Leak</em> 을 없엔 장면이다. 하지만 결과를 잘 모르는 경우에는 이 결과들이 맞는지 아닌지 쉽게 구별할 수 있는 정도는 아니다. 즉 아주 정확한 결과를 원하는게 아니라면 그냥 써도 된다는 말이다.</p>

<p>두번째는 데이터 구조와 메모리 레이아웃 최적화다. 가장 맨처음 이를 구현할 때는 링크드 리스트의 2D 그리드의 형태로 만들었다고 한다. 각각의 리스트의 노드는 다음노드를 가리키는 포인터와 <em>G-Buffer</em> 를 참조하기 위한 명시적인<sup id="fnref:C2" role="doc-noteref"><a href="#fn:C2" class="footnote">1</a></sup> 인덱스로 구성되었다고 한다. 하지만 이 구조는 <em>GPU</em> 에서의 두가지 쓰레드 동기화를 필요로 했다. 하나는 <em>Global Node Pool</em> 에서 비어있는 노드를 찾기위한 <em>Global</em> 동기화<sup id="fnref:C1" role="doc-noteref"><a href="#fn:C1" class="footnote">2</a></sup>, 나머지는 헤드 포인터(<em>Light-Space Data</em>)를 업데이트하기 위한 <em>Per-Texel</em> 동기화<sup id="fnref:C1:1" role="doc-noteref"><a href="#fn:C1" class="footnote">2</a></sup>였다. 동기화를 많이 걸면 걸수록 성능상으로는 그다지 좋지않다. 그렇기 때문에 데이터 구조를 바꾸었다고 한다.</p>

<p>여러 시도 끝에 가장 성공적인 결과는 리스트의 각 노드의 크기를 줄이는 것이였다. 이를 위한 준비는 노드를 저장하기 위한 <em>Screen-Space Grid</em> 버퍼를 미리 할당한다. 그리고 각 노드들은 자신을 기준으로한 다음 노드의 오프셋을 저장한다. 이는 <em>Linked-List</em> 의 기준으로 보자면 <em>Next Pointer</em> 가 된다. 이를 논문에서는 간접적인(<em>Implcit</em>) <em>G-Buffer</em> 인덱스라고 부른다. 이렇게 계속 픽셀의 노드 정보를 참조하면서 픽셀의 위치를 <em>Linked-List</em> 의 형태로 나타낼 수 있는 것이다. 아래 중간의 그림의 노란색 화살표는 이를 간단하게 나타냈다.</p>

<p><br />
<img src="/images/fts_SimpleLayout.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>이는 <em>IZB Node</em> 의 크기도 반으로 줄이고, 위에서 언급한 두가지의 동기화 중 <em>Global</em> 동기화를 안할 수 있게 되었다. 32spp 그림자를 보여주기 위해서는 적어도 픽셀별로 8개의 노드가 필요했다. 이렇게 반으로 노드의 크기를 줄임으로써 큰 퍼포먼스 향상을 얻게 되었다.</p>

<p>세번째는 헤드 포인터를 가지고 있는 <em>Light-Space Buffer</em> 의 해상도다. 일반적인 <em>Shadow Mapping</em> 기법의 <em>Shadow Map</em> 의 해상도는 보여지는 정도를 결정하지만, 여기서의 해상도는 퍼포먼스를 결정한다.(<em>La</em>) 1920 x 1080 을 기준으로 추천하는 해상도는 1400 ~ 2500 사이라고 한다.</p>

<p>네번째로는 기존의 <em>Shadow Mapping</em> 의 잘 알려진 기법인 <em>Cascaded Shadow Mapping</em><sup id="fnref:P1" role="doc-noteref"><a href="#fn:P1" class="footnote">3</a></sup> 을 이 기법에 적용시키는 것이다. 이 기법의 원리는 <em>View frustum</em> 을 원하는 갯수대로 쪼갠 후, 쪼개진 <em>frustum</em> 안의 오브젝트들의 <em>Shadow</em> 를 계산한다. 논문에서 쪼개는 방법은 <em>Sample Distribution Shadow Map</em> 과 <em>Logarithm Partitioning</em> 을 언급했다. 여기서는 쪼개진 <em>frustum</em> 마다 전부 <em>IZB</em> 를 생성한다. 이때 각각의 쪼개진 <em>frustum</em> 의 끝부분이 잘 맞도록 신경써야줘야 한다고 언급했다. 논문의 저자는 구현할때 <em>2D Texture Array</em> 를 사용하여 <em>IZB</em> 를 저장하고, 병렬로 각각의 <em>Detph Texture</em> 마다 <em>Light-Space Culling Prepass</em> 를 넣어줬다고 한다. 일반적으로 각각의 <em>Cascade</em> 를 계산할때는 한개당 하나의 <em>Pass</em> 를 사용하여 계산하는데, 여기서는 1 Pass 로 적절히 프리미티브를 나누어 성능 향상을 고려했다고 한다.</p>

<p><em>Cascade</em> 의 적용은 <em>Occluder Geometry</em> 의 <em>Rasterize</em> 퍼포먼스를 안고 가면서 <em>Thread Divergence</em> 의 시간을 줄여준다. 이는 사용시 적절한 타협점을 찾아야 한다는 뜻으로, 보통은 두개의 <em>Cascade</em> 를 사용하고, 복잡한 게임에서는 3개나 4개의 <em>Cascade</em> 를 사용하여 상황에 따라 뜀뛰는 시간을 최소화 시킨다. 아래 그림은 <em>Cascade</em> 의 효과를 증명해준다.</p>

<p><br />
<img src="/images/fts_cascaded-izb.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a>
</center>
<p><br /></p>

<p>다섯번째로는 <em>N dot L Culling</em> 이다. 일반적으로 <em>N dot L</em> 의 값이 음수가 되는 경우에는 0으로 클램핑하여 사용한다. 이 말은 값이 음수나 0 인 경우에는 무조건 <em>Shadow</em> 가 비춘다는 말이다. 이때는 <em>La</em> : 평균적인 <em>IZB</em> 리스트의 길이를 줄여 성능 향상을 해줄 수 있다고 한다. 보통은 10 ~ 15% 의 성능향상을 해준다고 한다.</p>

<p>여섯번째로는 <em>Early-Z</em> 의 개념을 응용한 <em>Early-Out</em> 이다. <em>Visibility Test</em> 에서 한 픽셀을 완전하게 그림자를 드리우는 경우, 다음 후속으로 같은 픽셀에 <em>Node</em> 가 추가될 필요가 없다. 그러므로 완전히 그림자 처리가 되는 부분은 <em>Node</em> 를 지워준다. 이때 <em>atomic</em> 연산을 사용하지 않는데, 최악에 경우에는 <em>Visibility Test</em> 를 다시할 수도 있다. <em>Early-Out</em> 은 추가적인 시간과 메모리를 요구함에도 불구하고 10 ~ 15% 의 성능향상을 보인다.</p>

<p>일곱번째로는 <em>Unchanged Mask</em> 를 이용한 메모리 동기화다. <em>Visibility Test</em> 는 메모리 대역폭, 처리량, 동기화로 인하여 병목이 일어난다. 픽셀 각각의 <em>Visibility Mask</em> 를 사용해 동기화를 한다. 정확히 말하면 각각의 폴리곤들이 픽셀의 가시성을 테스트 할때 <em>Race Condition</em> 을 피하기 위하여 동기화를 하여 <em>Visibility</em> 를 기록한다. 그러므로 <em>Visibility Mask</em> 는 반드시 폴리곤이 기존의 <em>Visibility</em> 를 바꿀 때만 업데이트된다. 바뀌는지 비교를 하기위해 이전에 사용한 마스크를 써야하지만, 이는 최고 14% 의 성능 향상을 보여준다고 한다.</p>

<p>마지막으로는 코드를 통한 <em>Latency Hiding</em> 이다. 단계가 복잡하여 <em>Memory Latency</em> 가 꽤나 긴편인데, GPU 에서는 이 <em>Latency</em> 를 감출 방법이 없다. 다행히 사전에 루프를 돌면서 <em>G-Buffer</em> 좌표를 계산하여 <em>Latency Hiding</em> 이 가능하다고 한다. 이는 5 ~ 15% 성능 향상을 보였다고 한다.</p>

<p>시스템 구현에 대한 디테일한 사항은 여기까지가 끝이다.</p>

<p>마지막으로 <em>Transparency Geometry</em> 를 처리하는 방법에 대해서 써보겠다. 이 기법의 <em>per-pixel</em> 테스트는 <em>Visibility Mask Buffer</em> 에 결과가 저장된다. <em>Visibility Mask Buffer</em> 의 효율적인 사용을 위해 항상 각 픽셀의 여러개의 32bit 데이터를 저장해준다고 한다. 이정도의 크기라면 단지 <em>Visibility</em> 만을 사용하는게 아니라 <em>Opacity</em> 또한 저장이 가능하다. 통상적인 가시성을 위한 투명 오브젝트의 처리 방법은 <em>Alpha to Coverage</em><sup id="fnref:C3" role="doc-noteref"><a href="#fn:C3" class="footnote">4</a></sup> 를 쓴다고 한다. 그리고 여기에서도 비슷한 방법을 사용할 수 있다고한다.</p>

<p>처음에는 <em>Coverage</em> 를 계산하기 위해 <em>Visibility Test</em> 를 해준다. 그리고 해당 알파가 저장된 텍스쳐를 참조하여 투명도를 가져오고, 해당 투명도를 사용하여 <em>Alpha to Coverage</em> 를 실행하여 투명도 마스크를 얻는다. 이를 비트 AND 연산으로 합쳐서 <em>Coverage</em> 를 <em>Visibility Buffer</em> 에 저장한다.</p>

<p>이 기법에서 알파 데이터를 처리하는 방법은 두가지로 나뉜다. 적은 비용으로 <em>Aliasing</em> 을 생기게 하는 방법과 높은 비용으로 완벽하게 구현하는 방법으로 나뉜다. 적은 비용의 방식은 <em>Alpha</em> 텍스쳐의 값을 <em>IZB Node</em> 를 순회하기 전에 가져와서 계산하는 방식이다. <em>Light-Space Texel</em> 을 기준으로 계산하므로 <em>Aliasing</em> 이 생길 것으롸 예상된다. 하지만 이 논문의 저자는 구현물을 이 방식으로 구현했다고 한다. 나머지 한개의 방식은 <em>IZB Node</em> 를 하나하나 순회하면서 <em>Alpha</em> 텍스쳐의 값을 가져와 계산하는 것이다. 이는 일반적으로 생각되는 텍스쳐 샘플링의 부하와 <em>Varing</em> 부하를 생기게 한다. 이는 꽤나 큰 비용이라고 한다.</p>

<p>여기까지가 끝이다. 논문에 그 다음 내용들은 전부 퍼포먼스들의 분석밖에 없다. 다음으로 쓸 내용은 <em>HFTS</em> 에 대한 내용이다.</p>

<h2>참조</h2>
<ul>
  <li><a href="http://cwyman.org/papers/tvcg16_ftizbExtended.pdf">Frustum-Traced Irregular Z-Buffers: Fast, Sub-pixel Accurate Hard Shadows</a></li>
  <li><a href="https://software.intel.com/en-us/articles/sample-distribution-shadow-maps">Intel Developer Zone : Sample Distribution Shadow Maps</a></li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:C2" role="doc-endnote">
      <p>명시적이란 뜻은 바로 넣어서 계산할 수 있는 절대적인 위치의 텍셀 인덱스를 뜻한다. <a href="#fnref:C2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:C1" role="doc-endnote">
      <p>여기서의 동기화는 <em>atomic</em> 의 개념을 말한다. 성능상의 단점은 다른 쓰레드에서 선점하는 경우에는 기다리는 것이다. <a href="#fnref:C1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:C1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:P1" role="doc-endnote">
      <p>이 블로그에서 <em>Cascaded Shadow Mapping</em> 에 대한 내용을 다루었었다. <a href="/2017/12/17/cascaded-shadow-mapping">여기</a>에서 볼 수 있다. <a href="#fnref:P1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:C3" role="doc-endnote">
      <p><a href="https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f</a> <a href="#fnref:C3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://zizon.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</article>

      </div>
    </main>
    
    <script>
      $("script[type='math/tex']").replaceWith(function() {
          var tex = $(this).text();
          return katex.renderToString(tex, {displayMode: false});
      });

      $("script[type='math/tex; mode=display']").replaceWith(function() {
          var tex = $(this).html();
          return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
      });
    </script>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2021 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
