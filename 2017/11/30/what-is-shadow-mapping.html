<!DOCTYPE html>
<html lang="ko">

  <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG"></script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>What Is Shadow Mapping</title>
  <meta name="description" content="※ 이 글은 opengl-tutorial : shadow mapping 게시물을 참고하여 쓰여졌습니다. 자세한 내용은 원문을 보는게 좋습니다. Shadow Mapping 실시간으로 그림자를 구현하기 위한 방법 중에 가장 널리 알려진 방법이다. 다른 방법들보다 구현하기 조금 쉬운편이긴 하나 이 방법은 완벽하지가 않기 때문에 방법 자체로는 완벽한 모습을 보이기 어렵고 다른 방법과 같이 사용하여 부족한 부분을 보완하여 사용해야 한다.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://suhyeokkim.github.io/2017/11/30/what-is-shadow-mapping">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://suhyeokkim.github.io/feed.xml">

  <meta name="google-site-verification" content="o3-a11YI0ZIYwUdcikrWBRObGOUHzk89IJF7CX0ieQk" />

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="What Is Shadow Mapping">
  <meta name="twitter:description" content="※ 이 글은 opengl-tutorial : shadow mapping 게시물을 참고하여 쓰여졌습니다. 자세한 내용은 원문을 보는게 좋습니다. Shadow Mapping 실시간으로 그림자를 구현하기 위한 방법 중에 가장 널리 알려진 방법이다. 다른 방법들보다 구현하기 조금 쉬운편이긴 하나 이 방법은 완벽하지가 않기 때문에 방법 자체로는 완벽한 모습을 ...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">What Is Shadow Mapping</h1>
    
    <p class="post-meta"><time datetime="2017-11-30T00:00:00+00:00" itemprop="datePublished">Nov 30, 2017</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Su-Hyeok Kim</span></span> • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>※ 이 글은 <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial : shadow mapping</a> 게시물을 참고하여 쓰여졌습니다. 자세한 내용은 원문을 보는게 좋습니다.</p>

<p><em>Shadow Mapping</em> 실시간으로 그림자를 구현하기 위한 방법 중에 가장 널리 알려진 방법이다. 다른 방법들보다 구현하기 조금 쉬운편이긴 하나 이 방법은 완벽하지가 않기 때문에 방법 자체로는 완벽한 모습을 보이기 어렵고 다른 방법과 같이 사용하여 부족한 부분을 보완하여 사용해야 한다.</p>

<!-- more -->

<p>일반적으로 <em>Shadow Mapping</em> 이라 말하면 아는 사람은 머릿속에 쉽게 떠오르는 방식이 있다. 빛의 반대쪽 방향에서 충분히 멀리 떨어져 한번 오브젝트를 그린다. 이때 <em>Pixel Shader</em> 를 null 로 설정해서 <em>Depth Buffer</em> 의 데이터만 가져온다. 또는 <em>Pixel Shader</em> 의 출력을 <em>Depth</em> 로 해도 된다. 그러면 보통 아래와 비슷한 2D 텍스쳐를 얻게 된다.</p>

<p><br />
<img src="/images/OGLTuto_DepthTexture.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>검은색에 가까워질수록(0에 가까워질수록) 해당 오브젝트의 위치가 가깝고, 흰색에 가까워질수록(1에 가까워질수록) 물체가 먼것이다. 오브젝트의 <em>Depth</em> 를 렌더링할 때 정점에 사용되는 <em>MVP</em> 변환 중 <em>View</em> 변환은 임의의 위치와 빛의 방향을 계산하여 적용해준다. <em>Camera</em> 를 기준으로 한게 아닌 <em>Light</em> 의 방향을 기준으로 하여 관련된 것을 <em>Light-Space</em> 라고 명명하는 경우도 더러 있다.</p>

<p>이제 생성된 <em>Shadow Map</em> 을 사용하는 방법에 대해 알아보자.</p>

<p><br />
<img src="/images/OGLTuto_lightandshadow.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>위 그림에서 노란색으로 보이는 표면은 빛이 닿는 부분이고, 검은색으로 보이는 표면은 어떤 오브젝트에 의해 가려져 그림자가 드리운 표면이다. 해당 그림 위의 <em>Depth Buffer</em> 를 응용하여 위처럼 가려지는 표면과 안가려지는 표면을 알아낼 수 있다.</p>

<p><em>Depth Buffer</em> 는 <em>Light-Space</em> 를 기준으로 데이터를 저장하고 있다. 그리고 <em>Shader</em> 에서는 <em>Local-Space</em> 로 정점의 위치가 들어오기 때문에 <em>Depth</em> 값을 비교하려면 두 값을 같은 공간으로 맞춰주어야 한다. <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial : Shadow Mapping</a> 에서는 <em>bias</em> 행렬과 <em>Light-Space</em> 가 적용된 행렬을 합성하여 입력으로 들어온 정점 데이터를 <em>Light-Space</em> 기준으로 바꿔준다.</p>

<p>그 다음 정점의 <em>Depth</em>(<em>Z</em>) 값과 <em>Depth Buffer</em> 에서 샘플링한 <em>Depth</em>(<em>Z</em>) 값을 비교하여 현재 정점의 <em>Depth</em> 값이 더 크면(멀면) 그림자를 적용시킨다. 이러면 기본적인 <em>Shadwo Mapping</em> 의 이론은 끝이다. 아래 간단한 <em>GLSL</em> 코드가 있다.</p>

<pre><code class="language-C">vec4 ShadowCoord = DepthBiasMVP * vec4(vertexPosition_modelspace, 1);

float visibility = 1.0;

if (texture( shadowMap, ShadowCoord.xy ).z &lt; ShadowCoord.z) {
    visibility = 0.5;
}
</code></pre>

<p>정점의 위치를 변환시키고, <em>Depth</em> 값에 따라 <em>visibility</em> 값을 변경시켜 그림자를 적용시킨다. 하지만 위에서도 언급했지만 <em>Shadow Mapping</em> 자체에는 조금 문제가 있다고 언급했다. 해당 코드의 결과를 보자.</p>

<p><br />
<img src="/images/OGLTuto_1rstTry.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>위 그림은 굉장히 난장판이다. 세가지의 문제가 있는데 사진의 전체를 봐도 쉽게 알 수 있는 빛이 닿는 영역이 그림자 처리되는 것, <em>Shadow acne</em> 가 생겼다고 말한다. 그리고 왼쪽아래 구석부분에 아주 조금 빛이 들어오는 것처럼 처리되는 것이 있다. 이는 <em>Peter Panning</em> 이라고 부른다. 그리고 마지막으로 그림자와 빛이 닿는 부분의 경계가 울퉁불퉁한게 보일 것이다. 이를 계단현상, <em>aliasing</em> 이라고 부르는데 흔히 게임에서 적용되는 <em>antialiasing</em> 의 반대말이 맞다.</p>

<p>첫번째로 해결할 문제는 <em>Shadow acne</em> 다. 이 문제는 아래 그림을 보면 쉽게 이해가 된다.</p>

<p><br />
<img src="/images/OGLTuto_shadow-acne.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>사선으로 나와있는 노란색 선들은 <em>Shadow Map</em> 을 기준으로 <em>Light-Space</em> 로 변환한 정점의 <em>Depth</em> 값의 기준을 뜻한다. 그리고 표면 자체는 <em>Shadow Map</em> 의 기준이 된다. 그림의 검은색 부분은 빛이 닿는 부분임에도 불구하고 그림자로 처리되는 부분인데, 이를 없에기 위해서는 값을 비교할때 단순하게 <em>bias</em> 를 더해주면 된다.</p>

<pre><code class="language-C">float bias = 0.005;
float visibility = 1.0;

if (texture( shadowMap, ShadowCoord.xy ).z &lt; ShadowCoord.z-bias) {
    visibility = 0.5;
}
</code></pre>

<p>이렇게 적용시키면 평면에서의 <em>acne</em> 들은 제거가 가능하지만 곡면에서의 <em>acne</em> 들이 제거가 안되기 때문에 <em>bias</em> 를 조금 수정해준다.</p>

<pre><code class="language-C">float bias = 0.005*tan(acos(cosTheta)); // cosTheta is dot( n,l ), clamped between 0 and 1
bias = clamp(bias, 0,0.01);
</code></pre>

<p>이러면 <em>Shadow acne</em> 들은 제거된다.</p>

<p><br />
<img src="/images/OGLTuto_VariableBias.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>다음은 <em>Peter Panning</em> 을 언급할 차례다. <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial</a> 에서는 이 문제의 해결책으로 굉장히 단순한 방법을 제시한다. <em>Peter Panning</em> 이 생기지 않도록 충분히 두꺼운 오브젝트를 배치하는 것이다.</p>

<p><br />
<img src="/images/OGLTuto_NoPeterPanning.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>이렇게 쉽게 해결된다.</p>

<p>마지막으로 다룰 문제는 <em>aliasing</em> 이다. 이는 <em>Shadow Mapping</em> 의 고질적인 문제로써 <em>anti-alisasing</em> 기법을 통해 해결해왔다.</p>

<p>첫번째로 <em>Shadow Map</em> 을 샘플링할 때 일반적인 색을 가져오는 샘플링이 아닌 다른 방식을 사용한다. <em>Shadow Map</em> 을 한번 샘플링할 때 하드웨어에서 주변의 텍셀을 샘플링해 주변 텍셀과 비교를 수행해 모든 비교결과를 이중선형 보간을 적용한 결과를 주는 샘플링 방식을 사용한다고 한다. 만약 이중선형 보간을 사용하지 않는다면 <em>Point Sampling</em> 을 여러번 하여 결과들을 사용해 <em>PCF</em> 를 적용시켜주면 된다. 이렇게 해주면 조금 부드러운 결과가 나오게 된다.</p>

<p>하지만 이로써는 만족할만한 결과를 얻을 수 없어 주변을 여러번 샘플링해 값을 가져온다. 미리 생성된 <em>offset</em> 을 사용해 기준 <em>UV</em> 주변을 샘플링한다.</p>

<pre><code class="language-C">for (int i=0;i&lt;4;i++){
  if ( texture( shadowMap, ShadowCoord.xy + poissonDisk[i]/700.0 ).z  &lt;  ShadowCoord.z-bias ){
    visibility-=0.2;
  }
}
</code></pre>

<p>미리 생성된 <em>offset</em> 은 <em>Poisson Disc</em> 방식으로 생성된듯하다. <em>visibility</em> 변수는 색의 어두움을 결정하는 변수로 한번 <em>Depth Test</em> 에 걸리면 0.2를 줄여 0.2 ~ 1 사이의 값을 가진다.</p>

<p>이렇게 두가지 방식으로 <em>anti-aliasing</em> 을 해주면 제법 그럴듯한 결과가 나온다.</p>

<p><br />
<img src="/images/OGLTuto_SoftShadows_Wide.png" alt="" class="center-image" /></p>
<center>출처 : <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial</a>
</center>
<p><br /></p>

<p>또한 <em>UV</em> 좌표에 <em>offset</em> 을 주는 방법은 꽤나 많다. 위의 방법은 랜덤으로 고정된 부분만 체크하지만 이 방법에 임의로 <em>offset</em> 돌려주는 방법도 있다.</p>
      <h2>
        
        
          참조
        
        
      </h2>
    

<ul>
  <li><a href="http://www.opengl-tutorial.org/kr/intermediate-tutorials/tutorial-16-shadow-mapping/">OpenGL Tutorial : Tutorial 16 Shadow mapping</a></li>
  <li><a href="http://ogldev.atspace.co.uk/www/tutorial42/tutorial42.html">OGLdev : Percentage Closer Filtering</a></li>
  <li><a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">GPU Gems : Chapter 11. Shadow Map Antialiasing</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Supersampling#Poisson_disc">Wikipedia : SuperSampling#poisson_disc</a></li>
</ul>

  </div>

  
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://suhyeokkim-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</article>

      </div>
    </main>
    
    <script>
      $("script[type='math/tex']").replaceWith(function() {
          var tex = $(this).text();
          return katex.renderToString(tex, {displayMode: false});
      });

      $("script[type='math/tex; mode=display']").replaceWith(function() {
          var tex = $(this).html();
          return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
      });
    </script>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2022 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://suhyeokkim.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
