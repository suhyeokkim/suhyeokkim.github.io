<!DOCTYPE html>
<html lang="ko">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Using Compute Shader In Unity</title>
  <meta name="description" content="Compute Shader 는 DirectX 11 의 등장과 함께 본격적으로 쓰이기 시작했다. 지금은 GPGPU 의 본격적인 기능으로 CPU 에서 처리하기 힘든 계산량을 책임지는 중요한 기능으로 자리잡았다. 실시간으로 현실적인 그래픽을 구현하기 위해 요즘의 게임들은 Compute Shader 를 사용해서 여러 계산을 한다. 조금이라도 퍼포먼스가 필요하다면 당연히 쓰게되는 것이다. 사용하는 방법 자체는 간단하지만 Compute Shader 를 사용해 어떤 기능을 구현하는지가 중요하다. 간단하게 사용방법부터 알아보자. Unity 에서는 Compute Shader 를 위한 파일을 생성해야 한다. 프로젝트창에서 위 그림과 같이 생성해주면 된다. 그러면 아래와 같은 기본소스로 파일이 생성된다. // Each #kernel tells which function to compile; you can have many kernels #pragma kernel CSMain // Create a RenderTexture with enableRandomWrite flag and set it // with cs.SetTexture RWTexture2D&amp;lt;float4&amp;gt; Result; [numthreads(8,8,1)] void CSMain (uint3 id : SV_DispatchThreadID) { // TODO: insert actual code here! Result[id.xy] = float4(id.x &amp;amp; id.y, (id.x &amp;amp; 15)/15.0, (id.y &amp;amp; 15)/15.0, 0.0); } 위의 소스는 HLSL 로 코딩된 소스로 DirectX 11 을 기준으로 코딩되어 있다. UnityCG 파일안의 코드를 이용하면 GLSL 로 자동 컨버팅이 되기도 한다. 직접 GLSL 코드로 코딩하고 싶다면 GLSLPROGRAM 과 ENDGLSL 로 코드를 감싸주면 간단하게 해결된다. 내용은 간단하다. 각 텍셀별로 접근이 가능한 Texture 를 이용해서(DirectX 에서는 UAV 라고 칭한다.) Texture 에 값을 채운다. HLSL 의 자세한 문법과 사용방법은 MSDN : SV_GroupIndex, MSDN : Semantics 들을 참고하길 바란다. 또한 쉐이더에서 뿐만아니라 Unity 스크립트상에서도 데이터들을 연결해주어야 한다. 사용하는 유형은 간단하다. UnityEngine.Texture 에서 파생된 텍스쳐들, UnityEngine.RenderTexture, UnityEngine.ComputeBuffer 정도면 모든 활용이 가능하다. UnityEngine.RenderTexture 에서는 Cubemap 도 지원하니 간단하게 쓸 수 있다. 해당 인스턴스를 넘겨주는 방법은 아래와 같다. ComputeShader shader = ...; RenderTexture rt = ...; shader.SetTexture(&quot;Result&quot;, rt); 코드에서의 변수명을 맞추어 넣어주거나 해쉬값을 미리 가져와 넣어주면 된다. 다른 유형의 데이터들도 이런 방법으로 넣을 수 있다. 데이터를 넣어주면 다음은 Compute Shader 를 실행하여 결과를 얻어야 한다. 간단하게 함수호출만 해주면 된다. 방법은 아래와 같다. ComputeShader shader = ...; RenderTexture rt = ...; int kernelIndex = shader.FindKernel(&quot;CSMain&quot;); shader.Dispatch(kernelIndex, rt.width / 8, rt.height / 8, 1); 해당 Compute Shader 소스는 텍스쳐안에 값을 채우는 코드이기 때문에 위와같이 해주었다. Unity Reference : ComputeShader.Dispatch 와 위의 Compute Shader 소스를 참고하면 알겠지만 최대 3차원의 방식으로 Compute Shader 의 그룹을 설정하여 계산이 가능하다. Compute Shader 소스의 [numthreads(8,8,1)] 는 한 그룹의 Thread 갯수를 나타내고, ComputeShader.Dispatch 메소드는 몇개의 그룹을 실행시키는지 넘겨주는 메소드다. 아래 그림을 보면 조금더 쉽게 이해가 가능하다. 출처 : MSDN Compute Shader 는 DirectX 11 이상, Vulkan, OpenGL 4.3 이상, OpenGL ES 3.0 이상, Metal 에서 사용가능하다. 그 아래의 플랫폼은 지원하지 않는다. 또 유의해야 할점은 그래픽 드라이버별로 지원 기능이 조금씩 다를 수 있으니 기능을 유의하며 사용해야한다. Unity Manual : ComptuteShader 에서 조금 참고할 수 있다. Using Compute Buffer in Unity 에서 관련된 내용을 언급했으니 같이 보면 좋을듯 하다. 참조 MSDN : SV_GroupIndex MSDN : Semantics Unity Manual : ComptuteShader">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/2017/11/29/using-compute-shader-in-unity/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="f8AsB97UC1pp_K4EwkRaJYJZVC0P4j36RK_TGOPPGAU" />


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Using Compute Shader In Unity">
  <meta name="twitter:description" content="Compute Shader 는 DirectX 11 의 등장과 함께 본격적으로 쓰이기 시작했다. 지금은 GPGPU 의 본격적인 기능으로 CPU 에서 처리하기 힘든 계산량을 책임지는 중요한 기능으로 자리잡았다. 실시간으로 현실적인 그래픽을 구현하기 위해 요즘의 게임들은 Compute Shader 를 사용해서 여러 계산을 한다. 조금이라도 퍼포먼스가 필요하...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Using Compute Shader In Unity</h1>
    
    <p class="post-meta"><time datetime="2017-11-29T00:00:00+00:00" itemprop="datePublished">Nov 29, 2017</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Su-Hyeok Kim</span></span> • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>Compute Shader</em> 는 <em>DirectX 11</em> 의 등장과 함께 본격적으로 쓰이기 시작했다. 지금은 <em>GPGPU</em> 의 본격적인 기능으로 CPU 에서 처리하기 힘든 계산량을 책임지는 중요한 기능으로 자리잡았다. 실시간으로 현실적인 그래픽을 구현하기 위해 요즘의 게임들은 <em>Compute Shader</em> 를 사용해서 여러 계산을 한다. 조금이라도 퍼포먼스가 필요하다면 당연히 쓰게되는 것이다.</p>

<p>사용하는 방법 자체는 간단하지만 <em>Compute Shader</em> 를 사용해 어떤 기능을 구현하는지가 중요하다. 간단하게 사용방법부터 알아보자. Unity 에서는 <em>Compute Shader</em> 를 위한 파일을 생성해야 한다.</p>

<p><img src="/images/create_computeshader.png" alt="create computeshader" class="center-image" /></p>

<p>프로젝트창에서 위 그림과 같이 생성해주면 된다. 그러면 아래와 같은 기본소스로 파일이 생성된다.</p>

<pre><code class="language-C">// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D&lt;float4&gt; Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!

	Result[id.xy] = float4(id.x &amp; id.y, (id.x &amp; 15)/15.0, (id.y &amp; 15)/15.0, 0.0);
}
</code></pre>

<p>위의 소스는 <em>HLSL</em> 로 코딩된 소스로 <em>DirectX 11</em> 을 기준으로 코딩되어 있다. <em>UnityCG</em> 파일안의 코드를 이용하면 <em>GLSL</em> 로 자동 컨버팅이 되기도 한다. 직접 <em>GLSL</em> 코드로 코딩하고 싶다면 <em>GLSLPROGRAM</em> 과 <em>ENDGLSL</em> 로 코드를 감싸주면 간단하게 해결된다.</p>

<p>내용은 간단하다. 각 텍셀별로 접근이 가능한 <em>Texture</em> 를 이용해서(<em>DirectX</em> 에서는 UAV 라고 칭한다.) <em>Texture</em> 에 값을 채운다. <em>HLSL</em> 의 자세한 문법과 사용방법은 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a> 들을 참고하길 바란다.</p>

<p>또한 쉐이더에서 뿐만아니라 <em>Unity</em> 스크립트상에서도 데이터들을 연결해주어야 한다. 사용하는 유형은 간단하다. <strong>UnityEngine.Texture</strong> 에서 파생된 텍스쳐들, <strong>UnityEngine.RenderTexture</strong>, <strong>UnityEngine.ComputeBuffer</strong> 정도면 모든 활용이 가능하다. <strong>UnityEngine.RenderTexture</strong> 에서는 <em>Cubemap</em> 도 지원하니 간단하게 쓸 수 있다. 해당 인스턴스를 넘겨주는 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;

shader.SetTexture("Result", rt);
</code></pre>

<p>코드에서의 변수명을 맞추어 넣어주거나 해쉬값을 미리 가져와 넣어주면 된다. 다른 유형의 데이터들도 이런 방법으로 넣을 수 있다. 데이터를 넣어주면 다음은 <em>Compute Shader</em> 를 실행하여 결과를 얻어야 한다. 간단하게 함수호출만 해주면 된다. 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;
int kernelIndex = shader.FindKernel("CSMain");

shader.Dispatch(kernelIndex, rt.width / 8, rt.height / 8, 1);
</code></pre>

<p>해당 <em>Compute Shader</em> 소스는 텍스쳐안에 값을 채우는 코드이기 때문에 위와같이 해주었다. <a href="https://docs.unity3d.com/ScriptReference/ComputeShader.Dispatch.html">Unity Reference : ComputeShader.Dispatch</a> 와 위의 <em>Compute Shader</em> 소스를 참고하면 알겠지만 최대 3차원의 방식으로 <em>Compute Shader</em> 의 그룹을 설정하여 계산이 가능하다.  <em>Compute Shader</em> 소스의 <em>[numthreads(8,8,1)]</em> 는 한 그룹의 <em>Thread</em> 갯수를 나타내고, <em>ComputeShader.Dispatch</em> 메소드는 몇개의 그룹을 실행시키는지 넘겨주는 메소드다. 아래 그림을 보면 조금더 쉽게 이해가 가능하다.</p>

<p><br />
<img src="https://msdn.microsoft.com/dynimg/IC520438.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN</a>
</center>
<p><br /></p>

<p><em>Compute Shader</em> 는 <em>DirectX 11</em> 이상, <em>Vulkan</em>,  <em>OpenGL 4.3</em> 이상, <em>OpenGL ES 3.0</em> 이상, <em>Metal</em> 에서 사용가능하다. 그 아래의 플랫폼은 지원하지 않는다. 또 유의해야 할점은 그래픽 드라이버별로 지원 기능이 조금씩 다를 수 있으니 기능을 유의하며 사용해야한다. <a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a> 에서 조금 참고할 수 있다.</p>

<p><a href="/2017/08/01/using-compute-buffer-in-unity/">Using Compute Buffer in Unity</a> 에서 관련된 내용을 언급했으니 같이 보면 좋을듯 하다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a></li>
  <li><a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a></li>
</ul>

  </div>

  
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://zizon.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Su-Hyeok Kim - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
