<!DOCTYPE html>
<html lang="ko">

  <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG"></script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Hbao Plus Analysis 1</title>
  <meta name="description" content="HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다. 이전 hbao plus analysis 0 글에서 HBAO+ 을 알기위한 기본적인 개념들에 대해서 살펴보았다. 이번 글에서는 HBAO+ 의 구조와 Linearize Depth 와 Deinterleaved Texturing 에 대해서 알아보겠다.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/2017/11/15/hbao-plus-analysis-1">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="o3-a11YI0ZIYwUdcikrWBRObGOUHzk89IJF7CX0ieQk" />

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Hbao Plus Analysis 1">
  <meta name="twitter:description" content="HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다. 이전 hbao plus analysis 0 글에서 HBAO+ 을 알기위한 기본적인 개념들에 대해서 살펴보았다. 이번 글에서는 HBAO+ 의 구조와 Linearize Depth 와 Deinterleaved Texturing 에 대해서 알아보겠다.">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Hbao Plus Analysis 1</h1>
    
    <p class="post-meta"><time datetime="2017-11-15T00:00:00+00:00" itemprop="datePublished">Nov 15, 2017</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Su-Hyeok Kim</span></span> • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/linearize-depth/">linearize_depth</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/deintereaved-texturing/">deintereaved_texturing</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-0">hbao plus analysis 0</a> 글에서 <em>HBAO+</em> 을 알기위한 기본적인 개념들에 대해서 살펴보았다. 이번 글에서는 <em>HBAO+</em> 의 구조와 <em>Linearize Depth</em> 와 <em>Deinterleaved Texturing</em> 에 대해서 알아보겠다.</p>

<!-- more -->

<h2><em>HBAO+</em> Pipeline</h2>

<p><br />
<img src="/images/hbao+_pipeline_with_input_normals.png" alt="hbao+ with input normal" class="center-image" /></p>
<center>출처 : <a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a>
</center>

<p><br />
<img src="/images/hbao+_pipeline_without_input_normals.png" alt="hbao+ without input normal" class="center-image" /></p>
<center>출처 : <a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a>
</center>
<p><br /></p>

<p>그림이 두개가 있다. 하나는 <em>GBuffer</em> 를 사용할 시 <em>World-Space Normal</em> 버퍼와 <em>Depth Buffer</em> 를 넘겨주어 계산하는 방식과 입력으로 <em>Depth Buffer</em> 만 넘겨서 <em>Normal</em> 데이터를 계산하는 두가지 방식에 대한 파이프라인이다. 두가지의 차이는 <em>Normal</em> 데이터에 대한 처리방식만 다르다. 나머지 계산은 다를게 없다.</p>

<h2>Linearize Depths</h2>

<p>코드를 보면 가장 처음에 시작하는 단계는 바로 <em>Linearize Depths</em> 다. 이는 꽤나 알려진 방법이다. 하지만 필자는 <em>HBAO+</em> 를 볼때 처음 봤기에 어느 정도의 설명을 해놓아야겠다. <em>Linearize Depths</em> 를 알기 위해선 입력된 정점의 위치를 <em>Clipping-Space</em> 로 변환하는 방법이 어떻게 이루어지는지 알고 있어야 한다.</p>

<p>일반적인 오브젝트를 렌더링 할때는 <em>Shader</em> 에 입력으로 들어오는 정점의 기준 공간은 <em>Model-Space</em>(또는 <em>Local-Space</em>) <em>Position</em> 이다. 그래서 <em>MVP</em> 변환을 통해 <em>Rasterizer</em> 가 처리할 수 있도록 <em>Clipping-Space</em> 로 <em>Rasterizer</em> 로 넘어가기 전에 변환해주어야 한다.(전체적인 내용은 <a href="https://docs.google.com/presentation/d/10VzsjfifKJlRTHDlBq7e8vNBTu4D5jOWUF87KYYGwlk/edit#slide=id.g25f88339be_0_0">Model, View, Projection 변환</a> 에서 확인할 수 있다.
) 그래서 <em>Pixel Shader</em> 로 넘어간 데이터들은 픽셀별로 들어가고, 픽셀별로 들어간 정점들의 위치는 <em>Clipping-Space</em> 로 되어있다. 여기까지 이해했으면 아래 그림을 보자.</p>

<p><br />
<img src="/images/Graphics3D_ClipVolume.png" alt="frustum vs Clipping" class="center-image" /></p>
<center>출처 : <a href="https://www.ntu.edu.sg/home/ehchua/programming/opengl/CG_BasicsTheory.html">3D Graphics with OpenGL Basic Theory</a>
</center>
<p><br /></p>

<p>위 그림은 <em>View frustum</em> 과 <em>Clipping Volume</em> 을 보여준다. <em>View frustum</em> 은 <em>Perspective</em> 방식으로 카메라가 실제로 보여주는 공간을 시각화 한것이고, <em>Clipping Volume</em> 은 <em>MVP</em> 변환에서 <em>Projection</em> 행렬을 사용할시 <em>View frustum</em> 에서 <em>Clipping Volume</em> 으로 변환되는 볼륨을 시각화 한것이다. <em>Projection</em> 변환은 아래와 같다.</p>

<p><br />
<img src="/images/projection_matrix.png" alt="perspective projection matrix" class="center-image" /></p>
<center>출처 : <a href="https://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer
">Stackoverflow : Getting the true z value from the depth buffer</a>
</center>
<p><br /></p>

<p><em>Perspective Projection</em> 은 <em>frustum</em> 기준 위치를 <em>Cube</em> 기준 위치로 바꾸는 연산이기 때문에 실제 좌표의 왜곡이 발생한다. 우리는 Z(Detph) 값이 어떤식으로 왜곡되는지 알아야 한다. 우선 <em>Clipping-Space</em> 로 변환할때, <em>Perspective</em> 형식의 <em>View frustum</em> 의 <em>zNear</em>, <em>zFar</em> 사이의 Z 값을 [0~1] 값으로 매핑한다. 그러면 <em>zNear</em>, <em>zFar</em> 값을에 따라서 실제 좌표가 바뀐다. 그리고 값 자체가 실제 Z 값과 선형적으로 매핑되지 않는다. 아래 그림을 보자.</p>

<p><br />
<img src="/images/nonlinearDepth.png" alt="non linear depth" class="center-image" /></p>
<center>출처 : <a href="https://computergraphics.stackexchange.com/questions/5116/how-am-i-able-to-perform-perspective-projection-without-a-near-plane">Computer Graphics StackExchange : How am I able to perform perspective projection without a near plane?</a>
</center>
<p><br /></p>

<p>그림이 조금 헷갈릴수도 있다. 세로축의 <em>d</em> 값은 <em>Projection</em> 을 한 Z, <em>Depth</em> 값이고 가로축은 <em>World-Space</em> 의 Z 값이다. 조금 헷갈릴수도 있는 부분은 세로축의 기준값이 윗부분이 0이고 아랫부분이 1이다. 이 부분은 신경써서 봐야한다. 이해했다면 변경된 <em>Depth</em> 값은 실제 Z 값과 선형적인 관계가 아니고, 실제 Z 값으로 복원하려면 여러 연산을 해야하기에 <em>HBAO+</em> 에서는 <em>Depth</em> 값들을 <em>Linearize</em> 하는 과정을 맨 처음에 넣은 것이다. 실제 Z 값으로 복원하는 이유는 간단하다. <em>Linear</em> 하지 않은 <em>Depth</em> 값을 연산시에 사용하면 보다 부정확한 결과가 나오기 때문이다. 특히 <em>SSAO</em> 연산을 할때는 <em>Depth</em> 값이 기본이 되기 때문에 해주어야 한다.</p>

<p>이 단계에서의 결론은 간단하다. <em>Clipping-Space</em> 의 <em>Depth</em> 값을 <em>View-Space</em> 의 Z 값으로 변환하는 단계다. 처리하는 코드는 다른 단계에 비해 짧다. 만약에 넘겨준 <em>Depth</em> 데이터들이 <em>View-Space</em> 인 경우에는 옵션을 통해 처리할 수 있다.</p>

<h2>Deintereaved Texturing</h2>

<p>위의 그림에는 <em>Generate HBAO+</em> 라고 단순히 뭉뚱그려서 표현했지만 그 안에는 단순한 <em>Horizon based ambient occlusion(HBAO)</em> 계산만 있지는 않다. <em>Deintereaved Texturing</em> 이라는 테크닉과 함께 <em>HBAO</em> 를 계산한다. <em>Computer Engineering</em> 분야의 지식을 응용한 이론으로 개인적으로 이 이론을 접했을 떄 꽤나 충격이였다. 자세한 설명은 <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a> 슬라이드의 몇장과 함께 보자.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_51.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_51" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p><em>Deintereaved Texturing</em> 의 방법은 간단하다. 텍스쳐를 여러장으로 나누어 샘플링을 한 후 각각의 나눠진 텍스쳐를 샘플링한 결과를 하나로 합친다. 슬라이드에는 <em>Post-Processing</em> 을 기준으로 설명이 되어있다. 이점은 생각하면서 보자.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_52.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_52" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>한 텍스쳐를 여러장으로 나누는건 <em>Multiple Render Target</em> 을 사용해서 나눈다. 슬라이드는 4개를 기준으로 설명했지만 <em>DirectX10</em> 부터는 최대 8개까지 지원하기 때문에 16개로 나누어 샘플링한다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_53.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_53" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>다음은 나누어진 각각의 텍스쳐를 샘플링하여 원하는 알고리즘으로 결과를 낸다. 조각난 텍스쳐 한개당 한번 <em>DrawCall</em> 을 걸어준다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_54.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_54" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p><em>Deintereave</em> 를 하기전까지는 넓은 범위의 텍스쳐를 샘플링하여 캐시 효율이 많이 떨어졌지만 텍스쳐를 나누어 각각 할때마다 처리를 하게되니 캐시 효율의 이득을 얻었다. 또한 각각의 <em>DrawCall</em> 마다 텍스쳐의 용량이 조금만 필요하게 되니 대역폭의 이득도 얻게 된다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_55.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_55" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>한번의 <em>DrawCall</em> 로 나누어진 결과들을 합친다. <em>Deintereaved Texturing</em> 은 여기서 끝이다. 실제로 <em>HBAO+</em> 는 16개의 텍스쳐로 나누어 샘플링한다. <em>Multiple Render Target</em> 이 8개까지 지원되어 16개로 <em>Deintereave</em> 하려면 2번 <em>DrawCall</em> 을 해야한다. 또한 샘플링은 16번 <em>DrawCall</em> 을 하여 계산한다. 그래서 한번 <em>Deintereaved Texturing</em> 을 사용하여 <em>Post-Processing</em> 처리하려면 약 20번의 <em>DrawCall</em> 을 계산해야 한다. 절대적으로 큰 숫자가 아니기 때문에 크게 신경쓸 필요는 없어보인다.</p>

<p><br />
<img src="/images/gdc2013_ParticleShadowsAndCacheEfficientPost_62.png" alt="gdc2013_ParticleShadowsAndCacheEfficientPost_62" class="center-image" /></p>
<center>출처 : <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a>
</center>
<p><br /></p>

<p>엄청난 성과를 거둔게 보인다. 캐시 히트 확률이 굉장히 올라갔고, 시간도 많이 절약했다. <em>HBAO+</em> 의 성능향상을 시켜준 것이 이 <em>Deinterleaved Texturing</em> 인듯하다.</p>

<h2>Reconstruction of Normal</h2>

<p><em>HBAO+</em> 는 기본적으로 <em>Depth</em> 와 <em>Normal</em> 을 통해서 계산한다. 그렇기 때문에 외부에서 <em>Normal</em> 데이터를 넣어주거나 직접 만들어야 한다. 보통 <em>Deffered Rendering</em> 을 차용하는 시스템들은 간단하게 <em>GBuffer</em> 의 <em>Normal</em> 데이터만 넣어주면 된다. <em>Normal</em> 데이터를 가져오는 코드가 있으니 조금만 수정하여 사용하면 된다.</p>

<p><em>Normal</em> 데이터가 없는 경우에는 라이브러리 내에 직접 계산한다. 계산하는 픽셀을 기준으로 상하,좌우별로 <em>Depth</em> 와 화면상의 좌표계를 이용하여 <em>View-Space</em> 의 위치를 구한다음 위치가 상하, 좌우별로 가까운 픽셀의 위치 오프셋을 사용해 외적하여 <em>Normal</em> 값을 구한다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVidia HBAO+</a></li>
  <li><a href="https://developer.nvidia.com/sites/default/files/akamai/gameworks/samples/DeinterleavedTexturing.pdf">NVidia : Deintereaved Texturing</a></li>
  <li><a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/BAVOIL_ParticleShadowsAndCacheEfficientPost.pdf">GDC2013 : Particle Shadows &amp; Cache-Efficient Post-Processing</a></li>
  <li><a href="http://www.gdcvault.com/play/1017623/Advanced-Visual-Effects-with-DirectX">GDCVault : Particle Shadows &amp; Cache-Efficient Post-Processing Video</a></li>
</ul>

  </div>

  
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://zizon.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</article>

      </div>
    </main>
    
    <script>
      $("script[type='math/tex']").replaceWith(function() {
          var tex = $(this).text();
          return katex.renderToString(tex, {displayMode: false});
      });

      $("script[type='math/tex; mode=display']").replaceWith(function() {
          var tex = $(this).html();
          return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
      });
    </script>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2021 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
