<!DOCTYPE html>
<html lang="ko">

  <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG"></script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Using Gpu Instancing In Unity</title>
  <meta name="description" content="이 글은 Unity 5.6.1f 버젼에서 작성되었습니다. 다른 버젼에서는 에러가 날 수 있으니 참고 바랍니다. Using Texture2DArray in Unity 에 이어 DrawCall 을 줄이기 위한 방법에 대해서 소개하려한다. GPU Instancing 이라는 방법인데 TextureArray 와 같이 응용해서 사용하면 획기적으로 DrawCall 을 줄일 수 있다. 일반적으로 알려진 GPU Instancing 에 대해서 말하자면 컴퓨터의 RAM 에만 저장하던 데이터들을 GPU 메모리에 복사해놓고 GPGPU 나 쉐이더를 실행할 때 빠르게 데이터에 접근하는 것을 GPU Instancing 이라 한다. 만약 GPU Instancing 을 사용하지 않으면 매번 DrawCall 에 데이터를 넣어줘야하기 때문에 수많은 DrawCall 이 걸리게 되고 이는 CPU 의 시간을 뺏어먹게 되어 영 좋지 않은 일이 된다. 보통은 같은 동작을 하는 오브젝트들을 최적화할 때 쓰인다. 사용하게 되면 DrawCall 이 O(오브젝트 갯수) 로 되던것이 O(1) 의 갯수로 줄어든다. 그래서 TextureArray 와 같이 사용하게 되면 DrawCall 이 O(오브젝트 갯수 * 텍스쳐 갯수) 로 계산되던게 O(1) 로 바뀌어 버리니 CPU 시간을 엄청나게 많이벌 수 있다. 다만 GPU 메모리를 많이 잡아먹기 때문에 신경써서 데이터를 구성하지 않으면 무슨일이 일어날지 모른다.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/2017/06/11/using-gpu-instancing-in-unity/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="o3-a11YI0ZIYwUdcikrWBRObGOUHzk89IJF7CX0ieQk" />

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Using Gpu Instancing In Unity">
  <meta name="twitter:description" content="이 글은 Unity 5.6.1f 버젼에서 작성되었습니다. 다른 버젼에서는 에러가 날 수 있으니 참고 바랍니다. Using Texture2DArray in Unity 에 이어 DrawCall 을 줄이기 위한 방법에 대해서 소개하려한다. GPU Instancing 이라는 방법인데 TextureArray 와 같이 응용해서 사용하면 획기적으로 DrawCall...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Using Gpu Instancing In Unity</h1>
    
    <p class="post-meta"><time datetime="2017-06-11T00:00:00+00:00" itemprop="datePublished">Jun 11, 2017</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Su-Hyeok Kim</span></span> • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><strong>이 글은 Unity 5.6.1f 버젼에서 작성되었습니다. 다른 버젼에서는 에러가 날 수 있으니 참고 바랍니다.</strong></p>

<p><a href="/2017/06/04/using-texture2darray-in-unity/">Using Texture2DArray in Unity</a> 에 이어 <em>DrawCall</em> 을 줄이기 위한 방법에 대해서 소개하려한다. GPU Instancing 이라는 방법인데 <em>TextureArray</em> 와 같이 응용해서 사용하면 획기적으로 <em>DrawCall</em> 을 줄일 수 있다.</p>

<p>일반적으로 알려진 <em>GPU Instancing</em> 에 대해서 말하자면 컴퓨터의 RAM 에만 저장하던 데이터들을 GPU 메모리에 복사해놓고 GPGPU 나 쉐이더를 실행할 때 빠르게 데이터에 접근하는 것을 GPU Instancing 이라 한다. 만약 <em>GPU Instancing</em> 을 사용하지 않으면 매번 <em>DrawCall</em> 에 데이터를 넣어줘야하기 때문에 수많은 <em>DrawCall</em> 이 걸리게 되고 이는 CPU 의 시간을 뺏어먹게 되어 영 좋지 않은 일이 된다. 보통은 같은 동작을 하는 오브젝트들을 최적화할 때 쓰인다. 사용하게 되면 <em>DrawCall</em> 이 <em>O(<strong>오브젝트 갯수</strong>)</em> 로 되던것이 O(1) 의 갯수로 줄어든다. 그래서 <em>TextureArray</em> 와 같이 사용하게 되면 <em>DrawCall</em> 이 <em>O(<strong>오브젝트 갯수</strong> * <strong>텍스쳐 갯수</strong>)</em> 로 계산되던게 <em>O(<strong>1</strong>)</em> 로 바뀌어 버리니 CPU 시간을 엄청나게 많이벌 수 있다. 다만 GPU 메모리를 많이 잡아먹기 때문에 신경써서 데이터를 구성하지 않으면 무슨일이 일어날지 모른다.</p>

<!-- more -->

<p>기술을 써보기 전에 우선 구현 사항부터 생각해야 한다. 필자는 Unity 에서 지원하는 <strong>SkinnedMeshRenderer</strong> 가 <em>DrawCall</em> 배칭을 해주지 않아 간단한 스키닝을 직접 구현하였다. <strong>SkinnedMeshRenderer</strong> 가 많은 기능을 지원하긴 하지만 <strong>SkinnedMeshRenderer</strong> 컴포넌트의 갯수가 절대적으로 많아지고 매터리얼이 늘어나게 되면 어쩔 수 없이 원하는 기능을 붙여 직접 구현해야 한다. <a href="https://github.com/hrmrzizon/InstancedSkinningExmaple.git">InstancedSkinning</a>에서 참고할 수 있다.</p>

<p>해야할 것은 두가지다. 쉐이더에서 데이터를 선언 후 직접 사용하는 코드를 짜주어야 하고, 스크립트에서는 필요한 데이터를 모아서 넣어주기만 하면 된다. 말로는 간단하지만 신경써주어야 할것이 많다. 필자 역시 간단하다고 생각하여 시작했으나 꽤 많은 삽질 끝에 성공했다.</p>

<p><em>GPU Instancing</em> 의 핵심은 GPU 메모리에 어떤 데이터들을 어떻게 옮겨놓고 그 데이터들을 어떻게 사용하느냐가 제일 핵심이다. 스크립트에서는 <strong>MaterialPropertyBlock</strong> 인스턴스를 통해 데이터를 한꺼번에 세팅하고 <em>Graphics.DrawMeshInstanced</em> 메소드를 호출해 그린다. 보통은 매 프레임별로 <em>Graphics.DrawMeshInstanced</em> 호출하기 때문에 적당히 코딩이 되어있다면 필요할때마다 <strong>MaterialPropertyBlock</strong> 인스턴스에 데이터를 갱신해주기만 하면 된다. <strong>MaterialPropertyBlock</strong> 은 쉐이더에 들어가는 정보들을 취급하는 데이터 뭉치(chunk)다. <strong>Material</strong> 은 쉐이더 정보와 필요한 데이터를 가지고 있는 인스턴스다. 쉐이더 정보를 가지고 있기 때문에 매터리얼의 갯수가 많으면 많을수록 <em>DrawCall</em> 의 갯수가 늘어난다. 하지만 <strong>MaterialPropertyBlock</strong> 은 <strong>Material</strong> 과는 다르게 정보만 가지고 있는 것이기 때문에 <em>DrawCall</em> 의 갯수가 늘어나지 않는다. <strong>MaterialPropertyBlock</strong> 에 관한 자세한 사용법은 <a href="https://docs.unity3d.com/kr/current/ScriptReference/MaterialPropertyBlock.html">Unity Reference : MaterialPropertyBlock</a> 을 참고하라.</p>

<p>아 그러면 쉐이더는 어디서 정의하냐고? <em>Graphics.DrawMeshInstanced</em> 메소드는 <strong>Material</strong> 과 <strong>MaterialPropertyBlock</strong> 둘다 필요하다. 적당히 데이터를 분리해서 취급하면 된다. 아래 그리는 코드를 살펴보자. <a href="https://github.com/hrmrzizon/InstancedSkinningExmaple/blob/master/Assets/2%20-%20InstancedSkinning/CharacterSet.cs">InstancedSkinning - CharacterSet</a> 에서 간추려서 가져왔다.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">CharacterData</span><span class="p">,</span> <span class="n">DrawData</span><span class="p">&gt;</span> <span class="n">drawDataDict</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">enumer</span> <span class="p">=</span> <span class="n">drawDataDict</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">();</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">enumer</span><span class="p">.</span><span class="nf">MoveNext</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">DrawData</span> <span class="n">data</span> <span class="p">=</span> <span class="n">enumer</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>

        <span class="n">data</span><span class="p">.</span><span class="nf">UpdateMatrix</span><span class="p">();</span>
        <span class="n">data</span><span class="p">.</span><span class="nf">UpdateMaterialblcok</span><span class="p">();</span>

        <span class="n">Graphics</span><span class="p">.</span><span class="nf">DrawMeshInstanced</span><span class="p">(</span>
                <span class="n">data</span><span class="p">.</span><span class="n">mesh</span><span class="p">,</span>
                <span class="m">0</span><span class="p">,</span>
                <span class="n">material</span><span class="p">,</span>
                <span class="n">data</span><span class="p">.</span><span class="n">mainMatrixList</span><span class="p">,</span>
                <span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">,</span>
                <span class="n">castShadow</span> <span class="p">?</span>
                    <span class="n">UnityEngine</span><span class="p">.</span><span class="n">Rendering</span><span class="p">.</span><span class="n">ShadowCastingMode</span><span class="p">.</span><span class="n">On</span> <span class="p">:</span>
                    <span class="n">UnityEngine</span><span class="p">.</span><span class="n">Rendering</span><span class="p">.</span><span class="n">ShadowCastingMode</span><span class="p">.</span><span class="n">Off</span><span class="p">,</span>
                <span class="n">receiveShadow</span><span class="p">,</span>
                <span class="n">drawLayerNumber</span><span class="p">,</span>
                <span class="n">drawCamera</span>
            <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Material</strong> 인스턴스는 단 한개이며 <strong>Texture2DArray</strong> 를 사용해 모든 텍스쳐를 하나로 합쳐 <em>DrawCall</em> 을 줄였다. <strong>DrawData</strong> 는 <em>Graphics.DrawMeshInstanced</em> 메소드 호출을하기 위한 구조체 데이터다. 기본적으로 물체를 그릴때 필요한 <strong>Mesh</strong> 인스턴스와 각 그려야할 인스턴스 별로 필요한 변환행렬들을 가지고 있는 <em>DrawData.mainMatrixList</em>, 필요한 데이터를 저장하고 있는 <strong>MaterialPropertyBlock</strong> 인스턴스 <em>DrawData.block</em> 을 가지고 있다. <em>DrawData.UpdateMaterialblcok</em> 메소드는 필요한 데이터들을 <em>DrawData.block</em> 에 넘겨주는 메소드다.</p>

<p>여기까지 스크립트에서 해주어야할 것들에 대해 말했다. 필요한 데이터들을 준비하고 <em>Graphics.DrawMeshInstanced</em> 로 한꺼번에 그려주는게 핵심이다. 이제 쉐이더 코딩에 대해 알아보자. Unity 에서의 쉐이더 코딩은 굉장히 복잡하다. Unity 는 여러 플랫폼을 위한 엔진이기 때문에 여러 플랫폼, Graphics API 에 대한 세팅이 필요하며 <em>GPU Instancing</em> 을 사용할 때 약간의 애로사항이 있다.</p>

<p><em>GPU Instancing</em> 을 사용할 때 결국 데이터는 전부 배열로 들어오게 된다. 각종 쉐이더 언어(HLSL, GLSL)에서 지원하는 <em>instanceID</em> 라는 배열에 접근하기 위한 인덱스가 있다. 이 인덱스에 접근하는 기능을 여러 플랫폼과 Graphics API 지원을 위해 해당 기능을 전처리기 구문으로 감싸놓았는데 Unity 엔진 사용자는 접근을 할수가 없다. 즉 배열의 인덱스에 직접 접근이 불가능하다는 것이다. 이렇게 되면 깔끔하게 코딩이 안되서 굉장히 불편할 뿐만 아니라 데이터도 효율적으로 쓰지 못한다.</p>

<p>또한 <em>Graphics.DrawMeshInstanced</em> 를 사용하려면 옵션을 하나 붙여주어야 한다.</p>

<pre><code class="language-C">#pragma exclude_renderers d3d9 gles d3d11_9x
#pragma only_renderers d3d11 glcore gles3 metal vulkan

#pragma multi_compile_instancing

#include "UnityCG.cginc"
</code></pre>

<p>위와 같이 <em>UnityCG.cginc</em> 파일을 포함하기 전에 전처리기 옵션 : <em>multi_compile_instancing</em> 을 붙여주어야 한다. 저 옵션을 안붙이게 되면 컴포넌트 렌더러(<strong>MeshRenderer</strong>, <strong>SkinnedMeshRenderer</strong>)에서 개별로 쓰이는 쉐이더만 컴파일하게 되는데 그 상태에서 <em>Graphics.DrawMeshInstanced</em> 를 사용하게 되면 아예 렌더링이 되지 않는다. 그래서 <em>GPU Instancing</em> 에 필요한 쉐이더도 동시에 컴파일 하라는 옵션이 <em>multi_compile_instancing</em> 옵션이다.</p>

<p>해당 옵션위에 다른 옵션들이 쓰여져 있는데 directX9 버젼이나 OpenGL ES 2.X 버젼에서는 제대로된 <em>GPU Instancing</em> 을 사용하지 못하므로 <em>exclude_renderers</em> 에 명시된 Graphics API 에서 돌아가는 쉐이더는 컴파일하지 말라는 옵션으로 생각하며 된다. 또한 동시에 <em>only_renderers</em> 옵션도 사용했는데 이는 해당 Graphics API 를 위한 쉐이더만 컴파일하라는 옵션이다. 보통 두가지를 동시에 쓰지는 않지만 정확한 명시를 위해 적어놓았다. 이제 쉐이더 프로그램에서 인스턴싱된 버퍼들을 사용하는 방법과 편법에 대해서 알아보자.</p>

<pre><code class="language-C">struct a2v
{
	float3 uv : TEXCOORD0;
	float4 vertex : POSITION;
	UNITY_VERTEX_INPUT_INSTANCE_ID
};

struct v2f
{
	float4 vertex : SV_POSITION;
	float2 uv : TEXCOORD0;
};
</code></pre>

<p>여기서 주목할 것은 a2v 구조체에 있는 <em>UNITY_VERTEX_INPUT_INSTANCE_ID</em> 매크로다. 이는 각 쉐이더 별로 <em>instanceID</em> 를 정의해주는 매크로 인데, 역시나 여러 플랫폼을 위해 전처리기로 처리 되어있다. 그리고 a2v 는 버텍스 쉐이더에 들어가는 인자를 구조체로 묶어놓은 것인데 만약 프래그먼트 쉐이더에서 <em>GPU Instancing</em> 을 하려면 인자로 들어가는 v2f 구조체에 <em>UNITY_VERTEX_INPUT_INSTANCE_ID</em> 매크로의 정의가 필요할 것이다. 이 쉐이더는 필요가 없어 넣지 않은 상태이다. 이제 버퍼들을 정의하고 사용하는 방법에 대해서 알아보자.</p>

<pre><code class="language-C">#define UNITY_MAX_INSTANCE_COUNT 100

UNITY_INSTANCING_CBUFFER_START(_BonePositions)
	UNITY_DEFINE_INSTANCED_PROP(float4, _BonePosition0);
	UNITY_DEFINE_INSTANCED_PROP(float4, _BonePosition1);
	UNITY_DEFINE_INSTANCED_PROP(float4, _BonePosition2);
	UNITY_DEFINE_INSTANCED_PROP(float4, _BonePosition3);
	UNITY_DEFINE_INSTANCED_PROP(float4, _BonePosition4);
	UNITY_DEFINE_INSTANCED_PROP(float4, _BonePosition5);
UNITY_INSTANCING_CBUFFER_END

float4 GetPosition(uint index)
{
	switch(index)
	{
		case 0:
			return UNITY_ACCESS_INSTANCED_PROP(_BonePosition0);
		case 1:
			return UNITY_ACCESS_INSTANCED_PROP(_BonePosition1);
		case 2:
			return UNITY_ACCESS_INSTANCED_PROP(_BonePosition2);
		case 3:
			return UNITY_ACCESS_INSTANCED_PROP(_BonePosition3);
		case 4:
			return UNITY_ACCESS_INSTANCED_PROP(_BonePosition4);
		case 5:
			return UNITY_ACCESS_INSTANCED_PROP(_BonePosition5);
	}

	return float4(1, 1, 1, 1);
}

UNITY_INSTANCING_CBUFFER_START(_BoneMatrixs) /* 위 선언와 비슷함 */ UNITY_INSTANCING_CBUFFER_END

float4x4 GetMatrix(uint index) { /* 위 함수와 비슷함 */ }

v2f vert (a2v v)
{
	v2f o;

	UNITY_SETUP_INSTANCE_ID(v);

	uint boneIndex = v.uv[2];

	float4 pos = GetPosition(boneIndex);

	o.vertex = UnityObjectToClipPos(
					mul(
						GetMatrix(boneIndex),
						float4(v.vertex.xyz - pos.xyz,1)
					)
					+
					float4(pos.xyz, 0)
				);
	o.uv = v.uv.xy;

	return o;
}
&lt;!-- __) --&gt;
</code></pre>

<p>우선 데이터를 저장할 버퍼를 선언해야 한다. 이는 GPU 메모리에 저장되는 버퍼인데 DirectX 에서는 <em>constant buffer</em> 라고 하고, OpenGL 에서는 <em>uniform buffer object</em> 라고 한다. 하여튼 이렇게 선언되는 버퍼에 들어가는 정보는 <strong>Material</strong> 이나 <strong>MaterialPropertyBlock</strong> 에 저장한 정보들에서 똑같은 변수이름을 가진 변수에게 저장된다. 보통은 쉐이더의 <em>Properties</em> 에 선언된 변수들은 <strong>Material</strong> 에 저장하고, 버퍼 오브젝트들은 <strong>MaterialPropertyBlock</strong> 에 저장된 데이터와 맞춰준다. 둘의 사용용도가 거의 일치하기 때문이라고 보면된다.</p>

<p>선언하는 방법은 간단하다. <em>UNITY_INSTANCING_CBUFFER_START</em>, <em>UNITY_INSTANCING_CBUFFER_END</em> 로 정의할 영역을 정해주고 그 안에 필요한 데이터들을 <em>UNITY_DEFINE_INSTANCED_PROP</em> 구문을 사용하여 정의해주면 된다. <em>UNITY_DEFINE_INSTANCED_PROP</em> 구문에는 자료형과 이름을 써주면 알아서 정의가 된다. 이 역시 HLSL 과 GLSL 로 알아서 컨버팅 되도록 한것이다. 그리고 해당 변수에 접근할 때는 <em>UNITY_ACCESS_INSTANCED_PROP</em> 를 사용하여 접근하면 된다.  이렇게 해주면 <em>multi_compile_instancing</em> 때문에 일반적인 컴포넌트 렌더러에서 쓰는 쉐이더와 <em>Graphics.DrawMeshInstanced</em> 에서 쓰는 쉐이더로 알아서 컴파일된다. <em>UNITY_ACCESS_INSTANCED_PROP</em> 로 접근을 한 이유도 여기에 있다. <em>Graphics.DrawMeshInstanced</em> 를 사용할때는 배열에 접근해야 하고, 컴포넌트 렌더러를 사용할때는 단순 인스턴스에 접근해야한다. 즉 배열의 인덱스로 접근하기위해 <em>UNITY_ACCESS_INSTANCED_PROP</em> 를 사용한다고 보면된다.</p>

<p>근데 위 코드처럼 인스턴싱을 많이하게 되면 아래와 같은 에러를 띄우면서 컴파일이 안될때가 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Can't continue validation - aborting. (on d3d11)
Index Dimension 2 out of range (12000 specified, max allowed is 4096) for operand #1 of opcode #5 (counts are 1-based). Aborting. (on d3d11)
</code></pre></div></div>

<p>그래서 위 코드에서 바꿔준 것이 맨 위에있는 전처리기 정의 구문이다.</p>

<pre><code class="language-C">#define UNITY_MAX_INSTANCE_COUNT 100
</code></pre>

<p>이는 약간 HACK 한 방식으로 커스터마이징을 한것이다. <em>Graphics.DrawMeshInstanced</em> 에서 쓰이는 쉐이더는 배열로 변수들을 선언하는데 기본 배열의 길이가 500 이다. 물론 모바일 같은 플랫폼에서는 4를 나누어줘서 125 이긴 하지만 PC 대상으로 컴파일하면 정의한 변수 한개당 500개씩 정의가 되서 변환 행렬덕분에 엄청난 메모리를 먹게된다. 그리고 배열 아이템의 갯수 4096 개를 초과해서 에러가 나는 것이다. 그래서 전처리기로 처리한 것에 약간의 편법을 써서 <em>UNITY_MAX_INSTANCE_COUNT</em> 를 필요할때마다 정의해주면 배열의 크기를 맘대로 조정할 수 있다. 위의 코드는 에러를 막기위해 임시적으로 조절한 것이지만 참조한 인스턴스의 갯수가 적으면 직접 조정해주는 편이 낫다. 물론 인덱스를 벗어나지 않는 범위에서 말이다. 이 방법은 Unity 사이트에서 built-in 쉐이더를 받아 확인하여 코딩하였다.</p>

<p>그리고 굳이 배열로 선언하고 싶지 않고 한번 실행하는 쉐이더당 한개의 변수만 필요한 경우 아래와 같이 단순하게 정의해주면 된다.</p>

<pre><code class="language-C">UNITY_INSTANCING_CBUFFER_START(_FragmentBuffer)
	float _TextureIndex;
UNITY_INSTANCING_CBUFFER_END

UNITY_DECLARE_TEX2DARRAY(_MainTexArray);

fixed4 frag (v2f i) : SV_Target
{
	fixed4 col = UNITY_SAMPLE_TEX2DARRAY(_MainTexArray, float3(i.uv, _TextureIndex));
	return col;
}

</code></pre>
<!-- ___)(____) -->

<p>저렇게 하면 단순하게 사용할 수 있다. 물론 컴파일 에러는 안난다. 해당 코드는 <a href="https://github.com/hrmrzizon/InstancedSkinningExmaple">Github : InstancedSkinningExmaple</a> 에서 확인할 수 있다.</p>

<p>자세한 방법은 <a href="https://docs.unity3d.com/Manual/GPUInstancing.html">Unity Manual : GPU Instancing</a> 에 적혀있으니 참고하길 바란다. 글을 쓰는 현재 2017년 6월 12일에는 한글 문서는 존재하지도 않는다. 영어로 읽어야한다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://docs.unity3d.com/Manual/GPUInstancing.html">Unity Manual : GPU Instancing</a></li>
  <li><a href="https://www.slideshare.net/CassEveritt/approaching-zero-driver-overhead">Slideshare : Approach Zero Driver Overhead</a></li>
  <li><a href="https://docs.unity3d.com/kr/current/ScriptReference/MaterialPropertyBlock.html">Unity Reference : MaterialPropertyBlock</a></li>
</ul>

  </div>

  
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://zizon.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</article>

      </div>
    </main>
    
    <script>
      $("script[type='math/tex']").replaceWith(function() {
          var tex = $(this).text();
          return katex.renderToString(tex, {displayMode: false});
      });

      $("script[type='math/tex; mode=display']").replaceWith(function() {
          var tex = $(this).html();
          return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
      });
    </script>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2021 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
