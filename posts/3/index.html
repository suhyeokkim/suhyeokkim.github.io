<!DOCTYPE html>
<html lang="ko">

  <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG"></script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Appocrypha</title>
  <meta name="description" content="store limitless knowledges">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://hrmrzizon.github.io/posts/3/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Appocrypha" href="https://hrmrzizon.github.io/feed.xml">

  <meta name="google-site-verification" content="o3-a11YI0ZIYwUdcikrWBRObGOUHzk89IJF7CX0ieQk" />

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Appocrypha">
  <meta name="twitter:description" content="store limitless knowledges">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93000374-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Appocrypha</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/edu">Edu</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/12/17/cascaded-shadow-mapping">Cascaded Shadow Mapping</a>
          </h1>

          <p class="post-meta">Dec 17, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/csm/">csm</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="/2017/11/30/what-is-shadow-mapping">What is Shadow Mapping</a> 에서 <em>Shadow Mapping</em> 에 대한 간단한 번역 &amp; 설명을 적어놓았다. 이번 글에서는 <em>Shadow Mapping</em> 을 효과적으로 사용하기 위한 <em>Cascaded Shadow Mapping</em> 에 대하여 적어보겠다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/12/17/cascaded-shadow-mapping">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/30/what-is-shadow-mapping">What Is Shadow Mapping</a>
          </h1>

          <p class="post-meta">Nov 30, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shadow/">shadow</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/rendering/">rendering</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>※ 이 글은 <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">opengl-tutorial : shadow mapping</a> 게시물을 참고하여 쓰여졌습니다. 자세한 내용은 원문을 보는게 좋습니다.</p>

<p><em>Shadow Mapping</em> 실시간으로 그림자를 구현하기 위한 방법 중에 가장 널리 알려진 방법이다. 다른 방법들보다 구현하기 조금 쉬운편이긴 하나 이 방법은 완벽하지가 않기 때문에 방법 자체로는 완벽한 모습을 보이기 어렵고 다른 방법과 같이 사용하여 부족한 부분을 보완하여 사용해야 한다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/11/30/what-is-shadow-mapping">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/29/using-compute-shader-in-unity">Using Compute Shader In Unity</a>
          </h1>

          <p class="post-meta">Nov 29, 2017 • 
  
  
    
  
    
  
    
      <a href="/categories/unity/">unity</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><em>Compute Shader</em> 는 <em>DirectX 11</em> 의 등장과 함께 본격적으로 쓰이기 시작했다. 지금은 <em>GPGPU</em> 의 본격적인 기능으로 CPU 에서 처리하기 힘든 계산량을 책임지는 중요한 기능으로 자리잡았다. 실시간으로 현실적인 그래픽을 구현하기 위해 요즘의 게임들은 <em>Compute Shader</em> 를 사용해서 여러 계산을 한다. 조금이라도 퍼포먼스가 필요하다면 당연히 쓰게되는 것이다.</p>

<p>사용하는 방법 자체는 간단하지만 <em>Compute Shader</em> 를 사용해 어떤 기능을 구현하는지가 중요하다. 간단하게 사용방법부터 알아보자. Unity 에서는 <em>Compute Shader</em> 를 위한 파일을 생성해야 한다.</p>

<p><img src="/images/create_computeshader.png" alt="create computeshader" class="center-image" /></p>

<p>프로젝트창에서 위 그림과 같이 생성해주면 된다. 그러면 아래와 같은 기본소스로 파일이 생성된다.</p>

<pre><code class="language-C">// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D&lt;float4&gt; Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!

	Result[id.xy] = float4(id.x &amp; id.y, (id.x &amp; 15)/15.0, (id.y &amp; 15)/15.0, 0.0);
}
</code></pre>

<p>위의 소스는 <em>HLSL</em> 로 코딩된 소스로 <em>DirectX 11</em> 을 기준으로 코딩되어 있다. <em>UnityCG</em> 파일안의 코드를 이용하면 <em>GLSL</em> 로 자동 컨버팅이 되기도 한다. 직접 <em>GLSL</em> 코드로 코딩하고 싶다면 <em>GLSLPROGRAM</em> 과 <em>ENDGLSL</em> 로 코드를 감싸주면 간단하게 해결된다.</p>

<p>내용은 간단하다. 각 텍셀별로 접근이 가능한 <em>Texture</em> 를 이용해서(<em>DirectX</em> 에서는 UAV 라고 칭한다.) <em>Texture</em> 에 값을 채운다. <em>HLSL</em> 의 자세한 문법과 사용방법은 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a> 들을 참고하길 바란다.</p>

<p>또한 쉐이더에서 뿐만아니라 <em>Unity</em> 스크립트상에서도 데이터들을 연결해주어야 한다. 사용하는 유형은 간단하다. <strong>UnityEngine.Texture</strong> 에서 파생된 텍스쳐들, <strong>UnityEngine.RenderTexture</strong>, <strong>UnityEngine.ComputeBuffer</strong> 정도면 모든 활용이 가능하다. <strong>UnityEngine.RenderTexture</strong> 에서는 <em>Cubemap</em> 도 지원하니 간단하게 쓸 수 있다. 해당 인스턴스를 넘겨주는 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;

shader.SetTexture("Result", rt);
</code></pre>

<p>코드에서의 변수명을 맞추어 넣어주거나 해쉬값을 미리 가져와 넣어주면 된다. 다른 유형의 데이터들도 이런 방법으로 넣을 수 있다. 데이터를 넣어주면 다음은 <em>Compute Shader</em> 를 실행하여 결과를 얻어야 한다. 간단하게 함수호출만 해주면 된다. 방법은 아래와 같다.</p>

<pre><code class="language-C#">ComputeShader shader = ...;
RenderTexture rt = ...;
int kernelIndex = shader.FindKernel("CSMain");

shader.Dispatch(kernelIndex, rt.width / 8, rt.height / 8, 1);
</code></pre>

<p>해당 <em>Compute Shader</em> 소스는 텍스쳐안에 값을 채우는 코드이기 때문에 위와같이 해주었다. <a href="https://docs.unity3d.com/ScriptReference/ComputeShader.Dispatch.html">Unity Reference : ComputeShader.Dispatch</a> 와 위의 <em>Compute Shader</em> 소스를 참고하면 알겠지만 최대 3차원의 방식으로 <em>Compute Shader</em> 의 그룹을 설정하여 계산이 가능하다.  <em>Compute Shader</em> 소스의 <em>[numthreads(8,8,1)]</em> 는 한 그룹의 <em>Thread</em> 갯수를 나타내고, <em>ComputeShader.Dispatch</em> 메소드는 몇개의 그룹을 실행시키는지 넘겨주는 메소드다. 아래 그림을 보면 조금더 쉽게 이해가 가능하다.</p>

<p><br />
<img src="https://msdn.microsoft.com/dynimg/IC520438.png" alt="" class="center-image" /></p>
<center>출처 : <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN</a>
</center>
<p><br /></p>

<p><em>Compute Shader</em> 는 <em>DirectX 11</em> 이상, <em>Vulkan</em>,  <em>OpenGL 4.3</em> 이상, <em>OpenGL ES 3.0</em> 이상, <em>Metal</em> 에서 사용가능하다. 그 아래의 플랫폼은 지원하지 않는다. 또 유의해야 할점은 그래픽 드라이버별로 지원 기능이 조금씩 다를 수 있으니 기능을 유의하며 사용해야한다. <a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a> 에서 조금 참고할 수 있다.</p>

<p><a href="/2017/08/01/using-compute-buffer-in-unity">Using Compute Buffer in Unity</a> 에서 관련된 내용을 언급했으니 같이 보면 좋을듯 하다.</p>

<h2>참조</h2>

<ul>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471569.aspx">MSDN : SV_GroupIndex</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509647.aspx">MSDN : Semantics </a></li>
  <li><a href="https://docs.unity3d.com/Manual/ComputeShaders.html">Unity Manual : ComptuteShader</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/18/DrawInstanced-vs-Merged-Instancing">Drawinstanced Vs Merged Instancing</a>
          </h1>

          <p class="post-meta">Nov 18, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a> 슬라이드에 따르면 <em>DrawInstanced</em> 함수를 사용하여 인스턴싱을 하는것보다 <em>vertexID</em> 를 사용하여 인스턴싱을 하는것이 빠르다고 한다. <em>vertexID</em> 를 쓰는 방법은 굉장히 단순하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VSOutput VS(uint id : SV_VertexID)
{
    VSOutput output;

    /*
        ...
    */

    return output;
}
</code></pre></div></div>

<p><em>SV_VertexID</em> <em>Semantic</em> 을 사용하여 값을 접근하기만 하면 된다. <em>vertexID</em> 는 말그대로 버텍스별 인덱스를 뜻한다. <em>SRV</em> 나 <em>UAV</em> 와 함께 사용하여 <em>Instancing</em> 을 하면된다.</p>

<p><br />
<img src="/images/gdc2014_vertexshadertricks_23.png" alt="Merge Instancing Performance" /></p>
<center>출처 : <a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a>
</center>
<p><br /></p>

<p>그림을 보면 AMD GPU 에서 확실히 퍼포먼스 차이가 난것을 확인할 수 있다. <del>스피커가 AMD 소속이라는 게 포인트</del></p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-3">Hbao Plus Analysis 3</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-2">hbao plus analysis 2</a> 글에서 <em>Horizon based ambient occlusion</em> 와 <em>Cross Bilateral Filter</em> 대해서 알아보았다. 이번 글에서는 부록의 느낌으로 <em>HLSL</em> 코드를 읽으면서 생소했던 기타 기법들에 대해서 써볼 것이다.</p>

<p>첫번째로 <em>Full Screen Triangle</em> 이라는 기법이다. 알고마면 굉장히 단순한 개념으로, 화면을 모두 덮는 한개의 삼각형을 그려서 모든 픽셀에 쉐이더를 돌릴 수 있게 해주는 기법이다. 아래 슬라이드를 보면 쉽게 이해가 갈것이다.</p>

<p><br />
<img src="/images/vertex-shader-tricks-by-bill-bilodeau-amd-at-gdc14-14-638.jpg" alt="Full Screen Triangle" class="center-image" /></p>
<center>출처 : <a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a>
</center>
<p><br /></p>

<p>단순하지만 처음 봤을 때는 조금 신박하게 느껴질 수도 있다. 두번째로는 모든 계산에 최대한 <em>HLSL Intrisic</em> 을 사용한다. 특히 벡터와 벡터사이의 거리를 계산할때 <em>dot product</em> 를 써서 하는게 정말 많았다. 어셈블리 레벨에서 달라지는것 같긴하나 정확한 이유는 알지 못했다. 추측해보면 GPU 에서 해당 명령어가 있지 않을까.. 라고 생각한다.</p>

<p>세번째도 위의 것과 비슷하다. 대부분의 데이터에 <em>MAD</em> 방식을 사용해서 계산한다. 하지만 이는 거의 공식적으로 정해진게 있다. <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471418.aspx">MSDN : mad  function</a> 레퍼런스에서도 나오듯이 어떤 GPU 에서는 위에서 추측한대로 하드웨어에서 지원하는 명령어라고 한다.</p>

<blockquote>
  <p>…
Shaders can then take advantage of potential performance improvements by using a native mad instruction (versus mul + add) on some hardware.
…</p>
</blockquote>

<p>또한 <em>HBAO+</em> 소스에서 찾은 주석에는 <em>GK104</em> 부터 특정 구간에서 10% 퍼포먼스 이득이 있다고 쓰여져 있다.</p>

<p>네번째는 나누기를 절대 쓰지 않는다. 나머지 연산(mod, A % B)는 간혹 쓰이지만 나누기는 절대로 쓰이지 않았었다. 혹시라도 필요하다면 전부 <em>Constant Buffer</em> 에 CPU 에서 역수를 취해서 넘겨주는 방식으로 되어 있었다. 이도 역시 하드웨어에서 동작하는 부분을 알고 짠듯하다.</p>

<p>다섯번째는 <em>HLSL</em> 코드를 <em>cpp</em> 소스에 <em>include</em> 하여 <em>Constant Buffer</em> 값을 갱신하는 코드였다. 여태까지 예전의 <em>DirectX</em> 소스만 보거나 <em>Unity</em> 에서만 작업을 해서 그런지 이런 기능은 굉장히 낯설었다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/visualfx/hbao/index.html">NVIDIA HBAO+</a></li>
  <li><a href="https://www.gdcvault.com/play/1020624/Advanced-Visual-Effects-with-DirectX">GDC 2014 : Vertex Sahder Tricks</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471418.aspx">MSDN : mad function</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-2">Hbao Plus Analysis 2</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/bilateral-filter/">bilateral_filter</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-1">hbao plus analysis 1</a> 글에서 <em>HBAO+</em> 에서 <em>Linearize Depth</em> 와 <em>Deinterleaved Texturing</em> 에 대해서 알아보았다. 이번 글에서는 <em>HBAO+</em> 의 핵심 알고리즘인 <em>Horizon Based Ambient Occlusion</em> 와 AO 블러에 사용되는 <em>Cross Bilateral Filter</em> 에 대해서 알아볼것이다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/11/15/hbao-plus-analysis-2">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-1">Hbao Plus Analysis 1</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/linearize-depth/">linearize_depth</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/deintereaved-texturing/">deintereaved_texturing</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p><strong>HBAO+ 3.1 버젼을 기준으로 글이 작성되었습니다.</strong></p>

<p>이전 <a href="/2017/11/15/hbao-plus-analysis-0">hbao plus analysis 0</a> 글에서 <em>HBAO+</em> 을 알기위한 기본적인 개념들에 대해서 살펴보았다. 이번 글에서는 <em>HBAO+</em> 의 구조와 <em>Linearize Depth</em> 와 <em>Deinterleaved Texturing</em> 에 대해서 알아보겠다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/11/15/hbao-plus-analysis-1">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/15/hbao-plus-analysis-0">Hbao Plus Analysis 0</a>
          </h1>

          <p class="post-meta">Nov 15, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/analysis/">analysis</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hbao/">hbao+</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>게임에서 쓰이는 실시간 렌더링에서 빛과 물체들의 상호작용을 완벽하게 현실적으로 표현하는 거의 불가능하다. 하지만 이를 위해 수십년동안 많은 엔지니어와 연구자들이 노력하여 부분적이고 제한된 환경에서의 빛과 물체의 상호작용을 현실 세계와 비슷하게 따라잡고 있다. 이번 글에서 살펴볼 것은 <em>Screen-Space Ambient Occlusion(SSAO)</em> 기반의 <em>HBAO+</em> 라는 라이브러리에 대해서 알아볼 것이다.</p>


        </div>

        
          <p class="post-continue">
            <a href="/2017/11/15/hbao-plus-analysis-0">Read on &rarr;</a>
          </p>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/31/shader-pipeline-4-geometry-shader">Shader Pipeline 4 Geometry Shader</a>
          </h1>

          <p class="post-meta">Oct 31, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>“<a href="/2017/10/31/shader-pipeline-3-fragment-shader">Fragemnt Shader</a>” 에서 <em>Fragment Shader</em> 에 대해 알아보았다. 다음은 <em>Geometry Shader</em> 에 대해서 써보려 한다.</p>

<p><em>Geometry Shader</em> 는 쉐이더 파이프라인에서 <em>Rasterizer Stage</em> 넘어가기 전의 <em>Geometry Stage</em> 의 마지막 단계로써 이전 쉐이더에서 넘긴  <em>Primitive</em> 데이터(point, line, triangle..)를 프로그래머가 원하는 복수의 <em>Primitive</em> 데이터로 변환할 수 있다. 삼각형을 삼각형의 중심을 나타내는 점으로 변환하는 쉐이더를 보자.</p>

<pre><code class="language-C">[maxvertexcount(1)]
void geom(vertexOutput input[3], inout PointStream&lt;geometryOutput&gt; pointStream)
{
    geometryShaderOutput o;

    o.vertex = (input[0].vertex + input[1].vertex + input[2].vertex) / 3;

    pointStream.Append(o);
}
</code></pre>

<p>매우 간단한 코드다. 간략하게 설명하자면, 맨 윗줄의 <em>maxvertexcount</em> 는 해당 지오메트리 쉐이더에서 <em>Stream</em> 으로 넘길 정점별 데이터의 갯수를 뜻한다. <em>Geometry Shader</em> 한번당 <em>Stream</em> 으로 넘길 <em>maxvertexcount</em> 의 한계는 정해지지 않았지만 크기는 1024 바이트로 정해져 있기 때문에 적절하게 사용해야 겠다. 그 다음줄의 인자들에 대해서 설명하면, 첫번째 <em>vertexOutput input[3]</em> 은 정해진 프리미티브의 값들을 뜻한다. 여기서는 삼각형을 기준으로 만들었기 때문에 정점별 정보가 3개가 있다. _inout PointStream<geometryOutput> pointStream_ 은 _Geometry Shader_ 의 최종 출력을 해주는 오브젝트다. _PointStream_ 은 점 프리미티브의 데이터를 받는 _Stream_ 으로써, 프리미티브가 다르면 각자 다른것을 사용할 수 있다.([MSDN : Getting Started with the Stream-Output Stage](https://msdn.microsoft.com/en-us/library/windows/desktop/bb205122.aspx)) 부등호 안에 있는 것은 일반적으로 알려진 제너릭이나 템플릿의 형태와 같으니 안에 출력으로 넘길 구조체를 넘겨주면 된다. 함수의 내용은 삼각형을 구성하는 각 정점의 위치의 평균을 구해 하나의 정점 정보만 _Stream_ 에 넘긴다.</geometryOutput></p>

<p><em>Stream</em> 은 총 두가지의 역할을 한다. 하나는 <em>Rasterizer</em> 단계로 넘겨서 쉐이더에서 처리를 할 수 있게 하는 통로 역할을 하고, 다른 하나는 드라이버 레벨에서 데이터를 출력해주는 통로 역할을 한다. 두가지의 일을 하기 때문에 <em>Stream</em> 의 개념으로 추상화한 것인가 싶다. 그리고 하나의 <em>Geometry Shader</em> 에서 여러개의 <em>Stream</em> 으로 출력이 가능하긴 하다. 최대 4개의 <em>Stream</em> 을 사용할 수 있다. <em>Stream</em> 을 선택해서 데이터를 받아올 수도 있으며, <em>Rasterizer</em> 로 보낼수도 있다. 자세한 사항은 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471424.aspx">MSDN : How To: Index Multiple Output Streams </a> 에서 확인하면 되겠다.</p>

<p>활용할 수 있는 다른 기능이 하나 더 있다. <em>instance</em> 기능이다. 아래 코드를 보자.</p>

<pre><code class="language-C">[instance(3)]
[maxvertexcount(1)]
void geom(vertexOutput input[3], uint InstanceID : SV_GSInstanceID, inout PointStream&lt;geometryOutput&gt; pointStream)
{
    geometryShaderOutput o;

    o.vertex = input[InstanceID].vertex;

    pointStream.Append(o);
}
</code></pre>

<p>해당 코드는 삼각형의 세개의 정점 위치를 넘기는 코드다. 달라진 것은 <em>instance(3)</em> 코드가 붙고, <em>uint InstanceID : SV_GSInstanceID</em> 파라미터가 생겨 코드 안에서 이를 활용한다. <em>instance(x)</em> 에 들어가는 x 는 반복하는 횟수를 뜻하고, <em>InstanceID</em> 파라미터는 반복하는 인덱스를 뜻한다. 같은 입력을 여러번 받아서 일정한 수만큼 반복하는 것이다.  <em>instance</em> 속성에 들어가는 숫자의 한계는 32까지다.</p>

<p><em>Geometry Shader</em> 는 <em>Shader Model 4.0</em> 에서 추가되었으며 뒤에 추가적으로 알아본 <em>multiple stream</em> 과 <em>instance</em> 키워드는 <em>Shader Model 5.0</em> 에서 확장된 기능들이다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb509609.aspx">MSDN : Geometry-Shader Object</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb205122.aspx">MSDN : Getting Started with the Stream-Output Stage</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471424.aspx">MSDN : How To: Index Multiple Output Streams</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471425.aspx">MSDN : How To: Instance a Geometry Shader</a></li>
  <li><a href="https://www.gamedev.net/forums/topic/600141-limit-on-maxvertexcount-gs/">GameDev : limit on maxvertexcount() GS</a></li>
</ul>

        </div>

        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/31/shader-pipeline-3-fragment-shader">Shader Pipeline 3 Fragment Shader</a>
          </h1>

          <p class="post-meta">Oct 31, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/render/">render</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/shader/">shader</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/hlsl/">hlsl</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>이전 글 : “<a href="/2017/10/31/shader-pipeline-2-rasterizer">Rasterizer</a>” 에서 <em>Rasterizer</em> 에 대해 알아보았다. 이번에는 <em>Fragment Shader</em> 을 알아보자.</p>

<p>쉐이더 파이프라인에서 <em>Rasterizer</em> 다음에 실행되는 것은 <em>Programmable Shader</em> 중에서 <em>Fragment Shader</em> 이다. <em>Fragment Shader</em> 은 <em>Pixel Shader</em> 라고도 불리는데, 이전에 <em>Rasterizer</em> 에서 조각낸 픽셀들을 단위로 실행되기 때문에 <em>Pixel Shader</em> 라고 불리기도 한다. 또한 각 픽셀은 조각난 단위이기 때문에 조각의 뜻을 가진 <em>Fragment Shader</em> 라고도 불린다. 이 글에서는 <em>Fragment Shader</em> 로 사용할 것이다.</p>

<p><em>Fragment Shader</em> 의 역할은 굉장히 단순하다. <em>Geometry Stage</em> 에서 넘어와 <em>Rasterizer</em> 단계에서 정리된 파라미터를 받고, 해당 픽셀의 색을 반환하면 끝난다. 역할은 단순하지만 그만큼 중요한 것이 <em>Fragment Shader</em> 다. 마지막으로 픽셀 단위로 보여주는 색을 바꿀 수 있는 <em>Programmable Shader</em> 로써 반복하는 비용이 꽤나 많아 일반적으로 오래 걸린다고 평가되지만 색을 바꿀 수 있어 그만큼 잘쓰면 굉장한 효과를 낼 수 있는 <em>Programmable Shader</em> 다.</p>

<p><img src="/images/fragment_shader.jpg" alt="Fragment Shader" /></p>

<p>가장 단순한 형태의 Unity 에서 사용하는 CG/HLSL 쉐이더를 보자.</p>

<pre><code class="language-C">#pragma fragment frag

struct v2f
{
    float4 vertex : SV_POSITION;
    float4 tangent : TANGENT;
    float3 normal : NORMAL;
    float4 texcoord : TEXCOORD0;
}

/*
  다른 코드 들..
*/

fixed4 frag(v2f i)
{
  return float4(1,1,1,1);
}
</code></pre>

<p>해당 쉐이더는 단순하게 흰색만 출력해주는 쉐이더다. 그만큼 매우 단순하고 쉽다. 하지만 많은 것들을 표현하려면 <em>frag</em> 함수의 코드는 점점 길어질 것이다.</p>

<p>또한 <em>Fragment Shader</em> 가 실행되는 시점에서 하드웨어, 드라이버 단계에서 지원하는 기능들도 있다. 일반적인 것들에 대해서 이야기 하자면 <em>Depth Buffer</em> 와 <em>Stencil Buffer</em> 가 있다. 두가지의 공통점은 각 픽셀 단위별로 데이터를 저장하는 버퍼들이다. <em>Depth Buffer</em> 는 <em>Clip-Space</em> 로 변환된 정점 값의 Z 값을 저장하는 용도로 쓰이는 버퍼로, 요즘 개발되거나 쓰이는 기술들은 <em>Depth Buffer</em> 를 엄청 많이 쓴다. 대표적으로 <em>Depth Pre-Pass</em> 가 있다. <em>Stencil Buffer</em> 는 픽셀별로 정수 데이터를 저장해서 사용하는 버퍼로써, 대부분 마스킹을 할 때 쓰인다.</p>

<h1>참조 자료</h1>

<ul>
  <li><a href="https://www.slideshare.net/kyruie/everything-about-earlyz">SlideShader : Everything about Early-Z</a></li>
</ul>

        </div>

        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/4">&laquo; Older</a>
    

    
      <a class="next" href="/posts/2">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>
    
    <script>
      $("script[type='math/tex']").replaceWith(function() {
          var tex = $(this).text();
          return katex.renderToString(tex, {displayMode: false});
      });

      $("script[type='math/tex; mode=display']").replaceWith(function() {
          var tex = $(this).html();
          return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
      });
    </script>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br />
&copy; 2015&ndash;2021 - <a href="/about/">Su-Hyeok Kim</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://hrmrzizon.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
